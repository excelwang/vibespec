# Meta-Test for VALIDATOR (interface)
# @verify_spec("VALIDATOR")
# Generated by Vibespec Compiler + TEST_DESIGNER Agent

import os
import sys
import unittest
from pathlib import Path

def verify_spec(spec_id):
    """Decorator for spec coverage tracking."""
    def decorator(func):
        func._verify_spec_id = spec_id
        return func
    return decorator

FIXTURES = [
    {"Input": "Valid specs", "Expected": "{errors: [], warnings: []}", "Case": "Normal"},
    {"Input": "Decision missing table", "Expected": "{warnings: [DecisionFormat]}", "Case": "Edge"},
    {"Input": "Workflow missing steps", "Expected": "{warnings: [WorkflowFormat]}", "Case": "Edge"},
    {"Input": "Interface missing fixtures", "Expected": "{warnings: [FixtureRequired]}", "Case": "Edge"},
    {"Input": "Any item missing Implements", "Expected": "{warnings: [Traceability]}", "Case": "Edge"},
    {"Input": "Dangling ref", "Expected": "{errors: [DanglingRef]}", "Case": "Error"},
]

def get_adapter(env='MOCK'):
    """Get MOCK or REAL adapter based on TEST_ENV."""
    if env == 'MOCK':
        class MockAdapter:
            def execute(self, input_key):
                for f in FIXTURES:
                    if f.get('Input') == input_key:
                        return f.get('Expected')
                return None
        return MockAdapter()
    elif env == 'REAL':
        import tempfile
        
        # Add src/scripts to path
        src_path = Path(__file__).resolve().parent.parent.parent.parent / 'src' / 'scripts'
        sys.path.insert(0, str(src_path))
        
        from validate import validate_specs
        
        class RealAdapter:
            def execute(self, input_data):
                """Test validator via validate_specs function."""
                with tempfile.TemporaryDirectory() as tmpdir:
                    specs_dir = Path(tmpdir) / 'specs'
                    specs_dir.mkdir()
                    
                    if input_data == "Valid specs":
                        # Create valid L0, L1, L2, L3 specs
                        (specs_dir / 'L0-VISION.md').write_text('''---
version: 1.0.0
---
# L0: Test Vision

## VISION.SCOPE

- **GOAL**: Test goal
''')
                        (specs_dir / 'L1-CONTRACTS.md').write_text('''---
version: 1.0.0
---
# L1: Test Contracts

## CONTRACTS.TEST

- **RULE1**: Script MUST do something.
  > Responsibility: Test
  > Verification: Test

(Ref: VISION.SCOPE)
''')
                        (specs_dir / 'L2-ARCHITECTURE.md').write_text('''---
version: 1.0.0
---
# L2: Test Architecture

## COMPONENTS

### COMPONENTS.TEST

#### TEST_COMPONENT

**Component**: Does something

(Ref: CONTRACTS.TEST)
''')
                        (specs_dir / 'L3-RUNTIME.md').write_text('''---
version: 1.0.0
---
# L3: Test Runtime

## [interface] TEST_INTERFACE

> Implements: [Component: COMPONENTS.TEST.TEST_COMPONENT]

```code
interface Test {}
```

**Fixtures**:
| Input | Expected | Case |
|-------|----------|------|
| x | y | Normal |
''')
                        errors, warnings = validate_specs(specs_dir)
                        if not errors:
                            return 'OK'
                        return f"Error: {errors[0]}"
                    
                    elif input_data == "Invalid ref":
                        # Create spec with dangling reference
                        (specs_dir / 'L0-VISION.md').write_text('''---
version: 1.0.0
---
# L0: Test Vision

## VISION.SCOPE

- **GOAL**: Test goal
''')
                        (specs_dir / 'L1-CONTRACTS.md').write_text('''---
version: 1.0.0
---
# L1: Test Contracts

## CONTRACTS.TEST

- **RULE1**: Script MUST do something.

(Ref: VISION.NONEXISTENT)
''')
                        errors, warnings = validate_specs(specs_dir)
                        if errors:
                            for err in errors:
                                if 'Dangling' in err or 'does not exist' in err:
                                    return 'Error: Dangling'
                        return 'OK'
                    
                    elif input_data == "Missing section":
                        # Create minimal spec that might trigger warnings
                        (specs_dir / 'L0-VISION.md').write_text('''---
version: 1.0.0
---
# L0: Test Vision

## VISION.SCOPE

- **GOAL**: Test goal
''')
                        errors, warnings = validate_specs(specs_dir)
                        if warnings:
                            return 'Warning'
                        return 'OK'
                
                return None
        return RealAdapter()
    return None

class TestVALIDATOR(unittest.TestCase):
    def setUp(self):
        self.env = os.environ.get('TEST_ENV', 'MOCK')
        self.adapter = get_adapter(self.env)

    @verify_spec("VALIDATOR")
    def test_compliance(self):
        if self.adapter is None and self.env == 'REAL':
            self.skipTest("REAL adapter not implemented for VALIDATOR")
        
        for fixture in FIXTURES:
            with self.subTest(case=fixture.get('Case', 'Unknown')):
                result = self.adapter.execute(fixture['Input'])
                self.assertEqual(
                    result, 
                    fixture['Expected'],
                    f"Input: {fixture['Input']}"
                )

if __name__ == '__main__':
    unittest.main()
