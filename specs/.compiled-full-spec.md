# VIBESPEC PROJECT SPECS (v3.2.0)
> üö® INSTRUCTION: You are an Agent reading the Project Bible.
> 1. Always check `L1: Contracts` before writing code.
> 2. `L0: Vision` defines the scope. Do not hallucinate features.
> 3. `L1` overrides `L3` if there is a conflict.

## üó∫Ô∏è INDEX
- [L0-VISION: VISION](#source-l0-vision)
- [L1-CONTRACTS: CONTRACTS](#source-l1-contracts)
- [L2-ARCHITECTURE: ARCHITECTURE](#source-l2-architecture)
- [L3-RUNTIME: RUNTIME](#source-l3-runtime)

---

<a id='source-l0-vision'></a>
# Source: L0-VISION.md
RELIABILITY: Use for Context
---

# L0: Vibespec Vision

> **Core Purpose**: User wants Vibespec to build specs that guide agents to generate user project source code with **maintainability**, **observability**, **determinism**, and **modularity**.

## VISION.SCOPE

User wants vibespec to be a **specification management framework** (not a code generator).

### In-Scope
- **VAL**: User wants vibespec to validate specs hierarchically (L0-L3).
- **TRACE**: User wants vibespec to track layer dependencies for traceability.
- **DOCS**: User wants vibespec to compile specs into a single authoritative document.
- **COV**: User wants vibespec to track test-to-spec coverage via `@verify_spec`.
- **IDEAS**: User wants vibespec to ingest raw ideas and refine them into specs.
- **REFL**: User wants vibespec to reflect on conversations and extract new ideas.
- **DEPS**: User wants vibespec to operate with zero third-party dependencies.
- **AUTO**: User wants vibespec to automate workflows via scripts first.
- **SKILL**: User wants vibespec to distribute as an agentic skill (SKILL.md).

### Out-of-Scope
- **LLM**: User does NOT want vibespec to generate code (delegated to external agents).
- **UI**: User does NOT want vibespec to provide UI design tools.
- **PM**: User does NOT want vibespec to manage projects or tickets.

## VISION.CODE_QUALITY_GOALS

User wants specs generated by Vibespec to guide agents to generate code with:

| Quality | Definition | Verification |
|---------|------------|--------------|
| **MAINTAINABILITY** | Clarity over cleverness. Modular, readable, low coupling. | Code review, static analysis |
| **OBSERVABILITY** | If you can't see it, assume it's broken. Logs, metrics, traces. | Monitoring coverage |
| **DETERMINISM** | Stochastic behavior is a bug unless required. Reproducible results. | Test repeatability |
| **MODULARITY** | High cohesion, low coupling. Single responsibility. | Dependency analysis |

## VISION.AUTOMATION

- **SCRIPT_FIRST**: User wants vibespec to script any formalizable task.
- **COGNITIVE_LOAD**: User wants vibespec to minimize LLM/human cognitive load via deterministic scripts.
- **EVOLUTION**: User wants vibespec to evolve by rigidifying patterns into code.
- **ITEM_CLASSIFICATION**: User wants vibespec to tag L3 items with execution type (PROMPT_NATIVE | SCRIPT | WORKFLOW | PROMPT_FALLBACK).

## VISION.CERTIFICATION

- **COMPLIANCE**: User wants vibespec to validate that agents correctly execute L1 Agent Acceptance and L3 Role Decisions prescribed in `specs/`.
- **PROOF**: User wants vibespec to generate certification artifacts (exams) to prove this compliance.

## VISION.EXTENSIBILITY

- **PROJECT_RULES**: User wants vibespec to allow project-specific validation rules.
- **RULE_LOCATION**: User wants vibespec to define custom rules in L1-CONTRACTS.
- **CORE_VS_CUSTOM**: User wants vibespec to separate universal rules from project-specific ones.
- **SCHEMA_DRIVEN**: User wants vibespec to use declarative schemas for rule definitions.

---

## VISION.TRACEABILITY

- **CHAIN**: User wants vibespec to support full traceability from request to verified code.
- **WORKFLOW**: User wants vibespec to follow: Request ‚Üí Breakdown ‚Üí Specs ‚Üí Implementation ‚Üí Verification.
- **GRANULARITY**: User wants vibespec to make every spec statement atomically addressable.
- **GOAL**: User wants vibespec to ensure every line of code satisfies a requirement.

## VISION.VIBE_CODING

- **TRUTH**: User wants vibespec to treat specs as the primary source of truth.
- **PARADIGM**: User wants vibespec to enable: Human defines Spec ‚Üí AI writes code ‚Üí Human & AI verify.
- **HUMAN_GATE**: User wants vibespec to require human approval before persisting spec changes.
- **AI_ASSIST**: User wants vibespec to leverage AI for generation, validation, and refinement.
- **SHIFT_LEFT**: User wants vibespec to catch errors at spec level, not implementation.

## VISION.PHILOSOPHY

- **HUMAN_CENTRIC**: User wants vibespec to produce atomic, readable specs.
- **LLM_CENTRIC**: User wants vibespec to generate concise, deterministic prompts.
- **SYSTEM_CENTRIC**: User wants vibespec to manage complexity via scripts (see AUTOMATION.SCRIPT_FIRST).
- **SEPARATION**: User wants vibespec to strictly separate assertions from their rationale.

## VISION.AGENT_AS_DEVELOPER

- **PRIMARY_CONSUMER**: User wants vibespec to compile a "Developer's Bible" for AI agents.
- **FULL_CONTEXT**: User wants vibespec to provide AI with "God's Eye View" of internals.
- **INFORMATION_COMPLETENESS**: User wants vibespec to retain all sections for code quality.

## VISION.COMPILATION_STRUCTURE

- **LLM_FRIENDLY**: User wants vibespec to optimize compiled output for agent consumption.
- **CONTEXT_ANCHORS**: User wants vibespec to include HTML anchors for precise retrieval.
- **NAVIGATION**: User wants vibespec to include preamble and TOC.
- **NOISE_REDUCTION**: User wants vibespec to strip frontmatter during compilation.

## VISION.FORMAL_SYNTAX

- **PRECISION_OVER_PROSE**: User wants vibespec to prioritize formal notation over prose.
- **FORMALISMS**: User wants vibespec to use Mermaid, JSON/Code schemas, pseudocode.
- **MULTIPLIER**: User wants vibespec to leverage high-density formal blocks.

## VISION.UBIQUITOUS_LANGUAGE

User wants vibespec to use precise, unambiguous terminology:
| Term | Definition |
|------|------------|
| Validate | Structural/static checks by scripts |
| Verify | Dynamic/runtime checks by tests |
| Assert | Hard blocking condition in code |
| Pipeline | Linear sequence of steps |
| Flow | Branching logic path |
| Violation | Breaking a spec rule |
| Error | Runtime crash or exception |

<a id='source-l1-contracts'></a>
# Source: L1-CONTRACTS.md
RELIABILITY: AUTHORITATIVE
---

# L1: Vibespec Behavior Contracts

> **Subject**: Agent | Script. Pattern: `[Agent|Script] MUST [action]`
> - Responsibility: WHO is accountable
> - Verification: HOW to measure compliance

---

## CONTRACTS.L3_TYPE_ANNOTATION

- **TYPE_REQUIRED**: Script MUST enforce `[Type: X]` annotation on all L3 items.
  > Responsibility: Validation ‚Äî ensure routing to correct execution mechanism.
  > Verification: Zero L3 items without type annotation.
  

- **SCRIPT_THRESHOLD**: Agent SHOULD assign `SCRIPT` type if task is deterministic and <100 LOC.
  > Responsibility: Decision quality ‚Äî balance automation vs complexity.
  > Verification: SCRIPT assigned for eligible tasks.
  

- **FALLBACK_RATIONALE**: Agent SHOULD document rationale for `PROMPT_FALLBACK` items.
  > Responsibility: Transparency ‚Äî explain automation barriers.
  > Verification: All PROMPT_FALLBACK items have rationale.

- **PROMPT_BATCHING**: Agent SHOULD batch adjacent PROMPT_NATIVE items.
  > Responsibility: Efficiency ‚Äî reduce LLM call overhead.
  > Verification: No unbatched adjacent prompts.
  

- **SCRIPT_NO_LLM**: Script MUST NOT contain LLM API calls.
  > Responsibility: Separation ‚Äî scripts are tools, not thinkers.
  > Verification: Zero LLM terms in SCRIPT items.
  

---

## CONTRACTS.LEAF_TYPE_PURITY

- **PURE_LEAF**: Script MUST enforce L2 leaf items are pure Agent OR pure Script type.
  > Responsibility: Separation ‚Äî no mixed responsibilities in leaf nodes.
  > Verification: Zero items with both Agent and Script keywords.
  

- **AGENT_KEYWORDS**: Agent indicators: ËØ≠‰πâÂàÜÊûê, ‰∏ä‰∏ãÊñá, Âà§Êñ≠, Êé®ÁêÜ, semantic, context, decide, infer.
- **SCRIPT_KEYWORDS**: Script indicators: ÈÅçÂéÜ, ËÆ°Êï∞, ÊéíÂ∫è, Ëß£Êûê, scan, count, sort, parse, format.

- **DECOMPOSE_MIXED**: Agent MUST decompose mixed items until each leaf is pure.
  > Responsibility: Granularity ‚Äî continue splitting until purity achieved.
  > Verification: All leaf items pass purity check.
  

---

## CONTRACTS.IDEAS_PIPELINE

- **BATCH_READ**: Script MUST read all idea files before analysis.
  > Responsibility: Data integrity ‚Äî complete picture for prioritization.
  > Verification: `files_read == files_exist`.
  

- **TIMESTAMP_ORDER**: Script MUST sort ideas by filename timestamp.
  > Responsibility: Preserve user intent sequence.
  > Verification: Processing order matches chronological order.
  

- **LEVEL_SEEKING**: Agent MUST classify each idea to highest applicable layer.
  > Responsibility: Shift-left ‚Äî prevent detail pollution.
  > Verification: Each segment has correct layer assignment.
  

- **DECOMPOSITION**: Agent MUST split mixed-level ideas and process sequentially.
  > Responsibility: Architectural integrity ‚Äî serialize changes.
  > Verification: Higher layers approved before lower layers processed.
  

- **APPROVAL_REQUIRED**: Agent MUST pause for human review after creating idea file.
  > Responsibility: Human gate ‚Äî prevent drift from user intent.
  > Verification: `notify_user` called after each idea creation.
  

- **COMPILE_PROMPT**: Agent SHOULD prompt for compilation when ideas/ is empty.
  > Responsibility: Artifact sync ‚Äî keep compiled output current.
  > Verification: Prompt shown when preconditions met.
  

- **CONFLICT_DETECT**: Agent MUST identify conflicting ideas before resolution.
  > Responsibility: Analysis ‚Äî detect overlapping or contradictory statements.
  > Verification: Conflict pairs logged before resolution applied.
  

- **CONFLICT_RES**: Agent MUST resolve detected conflicts by latest timestamp.
  > Responsibility: Truth source ‚Äî most recent intent wins.
  > Verification: Later idea values supersede earlier ones.
  

---

## CONTRACTS.REVIEW_PROTOCOL

- **SELF_AUDIT**: Agent MUST read full layer content after revision.
  > Responsibility: Quality ‚Äî catch errors before human review.
  > Verification: Self-check performed on each edit.
  

- **QUALITY_ALIGNMENT**: Agent SHOULD verify TARGET_PROJECT pillar alignment.
  > Responsibility: Maintainability, observability, determinism, modularity.
  > Verification: Warning raised for non-alignment.
  

- **HIERARCHY_CHECK**: Agent MUST load parent layer before editing child.
  > Responsibility: Traceability ‚Äî prevent drift from parent requirements.
  > Verification: Parent layer loaded on edit start.
  

- **REDUNDANCY**: Agent MUST flag duplicate definitions and overlapping content.
  > Responsibility: Lean specs ‚Äî avoid maintenance burden from duplicated/overlapping items.
  > Verification: Warning on redundant sections or items with overlapping scope.
  

- **CONTRADICTION**: Agent MUST flag conflicts with existing content.
  > Responsibility: Consistency ‚Äî detect axiom breakage.
  > Verification: Error on logical contradiction.
  

- **NOTIFICATION**: Agent MUST present all findings during approval.
  > Responsibility: Transparency ‚Äî enable informed decisions.
  > Verification: All findings shown to user.
  

- **SEQUENTIAL_ONLY**: Agent MUST NOT edit multiple layers in one turn.
  > Responsibility: Safety ‚Äî prevent cascading failures.
  > Verification: Single layer per turn.
  

- **SKILL_TRACEABILITY**: Agent MUST NOT edit SKILL.md without updating L3.
  > Responsibility: Traceability ‚Äî SKILL.md is derived artifact.
  > Verification: L3 updated before SKILL.md.
  

- **ROLE_FIRST_REVIEW**: Agent MUST evaluate revision quality through REVIEWER role before fixing validation errors.
  > Responsibility: Quality-first ‚Äî assess content quality before mechanical fixes.
  > Verification: REVIEWER role assessment logged before validate.py execution.
  

- **LAYER_SPECIFIC**: Agent MUST apply layer-specific review criteria during quality review.
  > Responsibility: Precision ‚Äî each layer has distinct validation focus.
  > Verification: Review checklist matches layer type (L0=Vision, L1=Contracts, L2=Arch, L3=Impl).
  

- **CASCADE_REVIEW**: Agent MUST evaluate downstream spec impact when reviewing current level.
  > Responsibility: Coherence ‚Äî identify required updates to child-level specs.
  > Verification: Review output includes proposed reorganization for L(N+1).
  

---

## CONTRACTS.REJECTION_HANDLING

- **AUTOMATED_RETRY**: Agent MAY self-correct up to 3 times for fixable errors.
  > Responsibility: Recovery ‚Äî minimize human intervention for minor issues.
  > Verification: Max 3 retry attempts.
  

- **AUTOMATED_GIVEUP**: Agent MUST revert and halt after 3 failed retries.
  > Responsibility: Safety ‚Äî prevent infinite loops.
  > Verification: Revert triggered on 4th failure.
  

- **HUMAN_REJECTION**: Agent MUST revert to pre-task state on user rejection.
  > Responsibility: Clean slate ‚Äî enable fresh approach.
  > Verification: Full revert on "try different approach".
  

- **NO_PARTIAL_COMMITS**: Script MUST ensure atomic layer commits.
  > Responsibility: Transactional integrity ‚Äî no broken states.
  > Verification: Layer fully approved or fully reverted.
  

---

## CONTRACTS.REFLECT

- **CONTEXT_BASED**: Agent SHOULD extract ideas from current conversation.
  > Responsibility: Efficiency ‚Äî use existing context.
  > Verification: Ideas extracted without external log access.
  

- **HUMAN_REVIEW**: Agent MUST get approval before saving distilled ideas.
  > Responsibility: Human gate ‚Äî verify AI insights.
  > Verification: Approval requested before file creation.
  

---

## CONTRACTS.SCRIPT_FIRST

- **TARGET**: Script MUST handle file I/O, validation, archival, formatting.
  > Responsibility: Reliability ‚Äî 100% deterministic for mechanical ops.
  > Verification: Scripts used for listed operations.
  

- **GOAL**: Script SHOULD reduce token consumption vs LLM approach.
  > Responsibility: Efficiency ‚Äî free LLM for reasoning.
  > Verification: Measurable token savings.
  

- **PROACTIVE**: Agent MUST propose scripts for repetitive workflows.
  > Responsibility: Evolution ‚Äî drive increasing autonomy.
  > Verification: Script proposal after 3+ repetitions.
  

- **DETERMINISM**: Script MUST use deterministic algorithms for mechanical tasks.
  > Responsibility: Predictability ‚Äî randomness is liability.
  > Verification: No stochastic behavior in scripts.
  

- **ZERO_DEPS**: Script MUST use only standard library.
  > Responsibility: Portability ‚Äî no supply chain risk.
  > Verification: No pip dependencies.
  

---

## CONTRACTS.SCRIPT_USABILITY

- **HELP_MESSAGE**: Script MUST implement `--help` with usage and arguments.
  > Responsibility: Discoverability ‚Äî reduce cognitive load.
  > Verification: Help output on `--help` flag.
  

- **AGENT_FRIENDLY_OUTPUT**: Script MUST produce output that is actionable, locatable, and structured.
  > Responsibility: Clarity ‚Äî enable agents to parse and act on results.
  > Verification: Output includes file paths, line numbers, IDs, and action recommendations.
  

---

## CONTRACTS.BOOTSTRAP

- **DETECTION**: Script MUST detect missing `specs/` and trigger bootstrap.
  > Responsibility: Safety ‚Äî prevent operation on uninitialized project.
  > Verification: Bootstrap triggered when specs/ absent.
  

- **SCOPE_INQUIRY**: Agent MUST ask user to describe project.
  > Responsibility: Capture ‚Äî get raw user intent.
  > Verification: Open-ended question asked.
  

- **SCOPE_REFORM**: Agent MUST convert input to SHALL/SHALL NOT statements.
  > Responsibility: Formalization ‚Äî transform vague to verifiable.
  > Verification: Output contains In-Scope and Out-of-Scope.
  

- **APPROVAL_GATE**: Agent MUST get approval before creating files.
  > Responsibility: Human gate ‚Äî prevent misdirected init.
  > Verification: Approval before any file creation.
  

- **CERTIFICATION_OUTPUTS**: Script MUST generate:
  - `tests/specs/agent/test_paper.md` (L1 Agent exams)
  - `tests/specs/decision/test_paper.md` (L3 Decision exams)
  > Responsibility: Artifact sync ‚Äî maintain current exam papers.
  > Verification: Required files exist after `vibespec compile`.
  

- **INITIALIZATION**: Script MUST create L0-VISION.md and ideas/ on approval.
  > Responsibility: Structure ‚Äî minimum viable spec foundation.
  > Verification: Required files exist after init.
  

- **CONFIG_TEMPLATE**: Script MUST auto-generate `vibespec.yaml` using the standard template `assets/templates/vibespec.yaml`.
  > Responsibility: Standardization ‚Äî prevent configuration drift at project inception.
  > Verification: `vibespec.yaml` matches template structure.
  

---

## CONTRACTS.TRIGGERS

- **TRIGGER_SCAN**: Script MUST scan ideas/ on bare `vibespec` invocation.
  > Responsibility: Default action ‚Äî process pending ideas.
  > Verification: Ideas scanned when no arguments.
  

- **TRIGGER_CAPTURE**: Script MUST save inline content as timestamped idea.
  > Responsibility: Capture ‚Äî save raw thoughts immediately.
  > Verification: File created with timestamp name.
  

- **TRIGGER_REVIEW**: Script MUST accept `vibespec review [ID]` to audit specific specs.
  > Responsibility: Audit ‚Äî on-demand quality check.
  > Verification: Runs review protocol on target spec.
  

- **TRIGGER_BUG**: Script MUST accept `vibespec bug [desc]` to initiate spec-based RCA.
  > Responsibility: Maintenance ‚Äî formalize bug fixing.
  > Verification: RCA steps logged before idea creation.
  

- **TRIGGER_ALIASES**: Script MUST recognize: `vibespec`, `vibespec`, `vibe spec`.
  > Responsibility: Usability ‚Äî reduce friction.
  > Verification: All aliases work identically.
  

- **IDLE_BEHAVIOR**: Agent MUST enter Validation Mode when ideas/ empty and SKILL.md exists.
  > Responsibility: Self-hosting ‚Äî continuous health monitoring.
  > Verification: Validation Mode triggered on conditions.
  

- **EMPTY_PROMPT**: Agent MUST invite brainstorming when project empty.
  > Responsibility: Onboarding ‚Äî friendly new project experience.
  > Verification: Invitation shown on empty state.
  

---

## CONTRACTS.VALIDATION_MODE

- **FULL_SCAN**: Script MUST run validation across all layers.
  > Responsibility: Completeness ‚Äî scan L0-L3.
  > Verification: All spec files validated.
  

- **REPORT**: Agent MUST summarize orphans, ratio warnings, terminology issues.
  > Responsibility: Feedback ‚Äî actionable maintenance report.
  > Verification: All findings listed.
  

- **FIX_PROPOSAL**: Agent MUST generate ideas for found errors.
  > Responsibility: Closing loop ‚Äî convert issues to work items.
  > Verification: Idea file created for each issue.
  

- **COMPILE_PROMPT**: Agent SHOULD prompt for compilation on pass.
  > Responsibility: Artifact sync ‚Äî keep output current.
  > Verification: Prompt shown on clean validation.
  

---

## CONTRACTS.CUSTOM_RULES

- **RULE_FILE**: Script MUST load rules from `specs/.vibe-rules.yaml`.
  > Responsibility: Separation ‚Äî project rules separate from framework.
  > Verification: File loaded when present.
  

- **RULE_SCHEMA**: Script MUST validate rule schema: id, layer, type, severity.
  > Responsibility: Correctness ‚Äî reject malformed rules.
  > Verification: Error on missing required fields.
  

- **VIBE_SPEC_RULES**: This project's custom rules:
  ```yaml
  rules:
    - id: SCRIPT_NO_LLM
      layer: 3
      type: forbidden_terms
      match_header: "[Type: SCRIPT]"
      terms: ["prompt(", "llm.", "openai", "anthropic"]
      severity: warning

    - id: PROMPT_NO_PSEUDOCODE
      layer: 3
      type: forbidden_pattern
      match_header: "PROMPT_NATIVE|PROMPT_FALLBACK"
      pattern: "```pseudocode"
      severity: warning
  ```
  

---

## CONTRACTS.SKILL_DISTRIBUTION

- **SKILL_MD**: Script MUST treat SKILL.md as single source of truth for capabilities.
  > Responsibility: Auditability ‚Äî version-controlled capabilities.
  > Verification: Capabilities match SKILL.md.
  

- **COMPLIANCE**: Script MUST validate SKILL.md against skill-creator schema.
  > Responsibility: Ecosystem compatibility.
  > Verification: Schema validation passes.
  

- **ENTRY_POINT**: Script MUST use `src/SKILL.md` as skill entry.
  > Responsibility: Location ‚Äî consistent skill path.
  > Verification: Loader finds skill at path.

- **TRIGGER_WORDS**: Script MUST recognize: vibespec, vibespec, vibe spec, refine specs.
  > Responsibility: Activation ‚Äî multiple aliases.
  > Verification: All triggers activate skill.
  

---

## CONTRACTS.METADATA

- **FRONTMATTER**: Script MUST validate YAML frontmatter with `version` field.
  > Responsibility: Automation ‚Äî machine-parseable metadata.
  > Verification: Error on missing version.

---

---

## CONTRACTS.TRACEABILITY

- **SEMANTIC_IDS**: Script MUST enforce `- **KEY**: ...` format (no sequential numbering).
  > Responsibility: Addressability ‚Äî unique semantic keys.
  > Verification: Error on numbered lists.

- **IN_PLACE_REFS**: Script MUST require `` on downstream items.
  > Responsibility: Linkage ‚Äî explicit parent references.
  > Verification: Error on missing refs.

- **DRIFT_DETECTION**: Script MUST reject references to non-existent IDs.
  > Responsibility: Integrity ‚Äî no dangling refs.
  > Verification: Error on invalid ref.

- **COMPLETENESS**: Script MUST ensure each upstream ID has downstream coverage.
  > Responsibility: Coverage ‚Äî no orphan requirements.
  > Verification: Error on 0% coverage.

- **ANCHORING**: Script MUST require at least one parent ref per downstream item.
  > Responsibility: Grounding ‚Äî all items anchored.
  > Verification: Error on unanchored items.

- **L2_L3_IMPLEMENTATION**: Script MUST warn if L2 Component has no L3 interface implementing it.
  > Responsibility: Implementation coverage ‚Äî every Component should have technical specification.
  > Verification: Warning on L2 Component without `` in L3.

---

---

## CONTRACTS.QUANTIFIED_VALIDATION

- **ATOMICITY**: Script MUST enforce <50 words per L0 statement.
- **DEPTH**: Script MUST enforce <=2 nesting levels.
- **TERMINOLOGY**: Script MUST validate controlled vocabulary usage.
- **RFC2119**: Script MUST require >=50% RFC2119 keyword density in L1.

---

## CONTRACTS.ALGEBRAIC_VALIDATION

- **MILLERS_LAW**: Script MUST enforce Fan-Out <= 7.
- **CONSERVATION**: Script MUST enforce coverage sum >= 100%.
- **EXPANSION_RATIO**: Script SHOULD warn if L(N)/L(N-1) ratio outside 1.0-10.0.
- **TEST_COVERAGE**: Script SHOULD warn if L3 leaf has no `@verify_spec` reference.

---

## CONTRACTS.L3_QUALITY

- **FIXTURE_REQUIRED**: L3 interface/algorithm MUST include Fixtures table.
  > Responsibility: Testability ‚Äî every interface needs concrete test cases.
  > Verification: Warning if `Fixtures` table missing.

- **CASE_COVERAGE**: Fixtures SHOULD include Normal, Edge, and Error cases.
  > Responsibility: Robustness ‚Äî test boundaries and failures.
  > Verification: Warning if any case type missing.

- **TYPE_SIGNATURE**: L3 interface MUST include typed function signature (code block).
  > Responsibility: Precision ‚Äî unambiguous contract for implementation.
  > Verification: Warning if no code block present.

- **INTERFACE_COMPATIBILITY**: Script MUST verify type compatibility between interoperating interfaces.
  > Responsibility: Integration ‚Äî ensure producer output matches consumer input.
  > Verification: Error if output type of producer does not match input type of consumer.

- **DECISION_FORMAT**: `[decision]` items MUST include a Logic Table (pipes `|`) or a Checklist (bullets `-`).
  > Responsibility: Clarity ‚Äî decisions must be structured, not free text.
  > Verification: Warning if body lacks `|` or `-`.

- **WORKFLOW_FORMAT**: `[workflow]` items MUST include a "**Steps**:" section.
  > Responsibility: Execution ‚Äî workflows are sequences of actions.
  > Verification: Warning if `**Steps**:` regex not found.

- **TRACEABILITY_TAG**: ALL L3 items MUST include an `` tag.
  > Responsibility: Traceability ‚Äî link every implementation detail to architecture.
  > Verification: Warning if `Implements:` tag missing.

---

## CONTRACTS.STRICT_TESTABILITY

- **DEFAULT_TESTABLE**: Items with MUST/SHOULD/MAY are testable requirements.
- **RATIONALE_SEPARATION**: Use `> Rationale:` block for explanations.
- **RFC2119_ENFORCEMENT**: Script MUST require RFC2119 keyword in L1 items.
- **MOCK_GENERATION**: Agent MUST generate mock objects for external interfaces.
  > Responsibility: Isolation ‚Äî unit tests must not depend on environment.
  > Verification: Mocks used in generated tests.

- **ENVIRONMENT_TOGGLE**: Script MUST support `TEST_ENV=MOCK|REAL` switch.
  > Responsibility: Flexibility ‚Äî validation (Mock) vs verification (Real).
  > Verification: Tests run against Real implementation when set.

- **MOCK_FIRST**: Agent SHOULD run tests in MOCK mode during development.
  > Responsibility: Early validation ‚Äî verify spec logic before implementation.
  > Verification: MOCK tests pass before REAL tests are attempted.

- **SKIP_UNIMPLEMENTED**: Script MUST report SKIP (not FAIL) for missing implementations in REAL mode.
  > Responsibility: Clarity ‚Äî distinguish "not implemented" from "implemented incorrectly".
  > Verification: REAL mode returns SKIP when adapter not found.

- **RESULT_STATES**: Script MUST support result states: PASS, FAIL, SKIP, ERROR.
  > Responsibility: Granularity ‚Äî enable precise test outcome reporting.
  > Verification: Test report includes all four states.

- **ROLE_ALWAYS_MOCK**: Role output MUST remain mocked regardless of TEST_ENV.
  > Responsibility: Determinism ‚Äî scripts can execute full tests without LLM.
  > Verification: Role adapter returns fixture values in both MOCK and REAL modes.

- **WORKFLOW_INTEROP_COVERAGE**: L3 workflow specs MUST cover interface interoperability.
  > Responsibility: Integration ‚Äî verify communication between components.
  > Verification: Workflow tests exercise cross-interface data flow.

- **FULL_WORKFLOW_REQUIRED**: L3 MUST define `full_workflow` covering all Roles and Components.
  > Responsibility: Completeness ‚Äî end-to-end test for entire system.
  > Verification: `workflow/test_full_workflow.py` invokes all roles and components.

- **L1_WORKFLOW_COVERAGE**: Validator MUST ensure every L1 Script item is covered by a realistic L3 workflow scenario.
  > Responsibility: Traceability ‚Äî L1 requirements verified through integration tests.
  > Verification: `validate.py` checks L1‚ÜíL3 workflow traceability. Refs must be part of a valid `[workflow]` item's Steps or Coverage section.

---

## CONTRACTS.COMPILATION

- **LLM_OPTIMIZED**: Script MUST produce single continuous markdown.

- **NAVIGATION**: Script MUST include TOC and preamble.
- **NOISE_REDUCTION**: Script MUST strip frontmatter, `` tags, and `**Fixtures**` sections.

---

## CONTRACTS.BUILD_STRATEGY

- **GAP_ANALYSIS_FIRST**: IMPLEMENTER MUST perform gap analysis before implementation.
  > Responsibility: Risk reduction ‚Äî understand current state before changes.
  > Verification: Gap report generated before any code modifications.

- **INCREMENTAL_REFACTOR**: IMPLEMENTER SHOULD prefer incremental changes over full rewrites.
  > Responsibility: Stability ‚Äî minimize disruption to working code.
  > Verification: Changes preserve git history continuity.

- **REWRITE_THRESHOLD**: Agent MUST request human approval if gap exceeds 70%.
  > Responsibility: Human oversight ‚Äî large changes require confirmation.
  > Verification: notify_user called when gap > 70%.

- **GAP_CATEGORIES**: Script MUST classify gaps as MISSING, OUTDATED, or ORPHAN.
  > Responsibility: Clarity ‚Äî different gap types require different actions.
  > Verification: Report includes categorized gap list.

- **SKILL_SYNC**: Script MUST synchronize `src/SKILL.md` with `skills` list in `vibespec.yaml`.
  > Responsibility: Consistency ‚Äî `vibespec.yaml` is single source of truth for active skills.
  > Verification: `src/SKILL.md` reflects configured skills.
  

- **AUTHORITATIVE_PROMPT**: Script MUST present `specs/.compiled-full-spec.md` as non-negotiable Law to Agent.
  > Responsibility: Compliance ‚Äî prevent agent improvisation.
  > Verification: Build script outputs "The file specs/.compiled-full-spec.md is not a suggestion‚Äîit is the LAW."

- **AGENT_DIRECTIVE_COMPLIANCE**: Script MUST inject `meta.agent_directive` from `vibespec.yaml` into the Prompt.
  > Responsibility: Customization ‚Äî project-specific agent instructions.
  > Verification: Build output includes "üß† AGENT DIRECTIVE: {content}".

---

## CONTRACTS.TERMINOLOGY_ENFORCEMENT

```yaml
standard_terms:
  Validate: Static checks (linting, structure)
  Verify: Dynamic checks (runtime tests)
  Pipeline: Linear sequence
  Flow: Branching logic
  Assert: Hard-blocking failure
  Error: Runtime exception
  Violation: Spec non-compliance
```

## CONTRACTS.TESTING_WORKFLOW

- **COVERAGE_REPORT**: Script MUST report L1 and L3 coverage percentages.
  > Responsibility: Visibility ‚Äî show testability gaps.
  > Verification: Report includes L1% and L3% values.

- **UNCOVERED_LIST**: Script MUST list uncovered spec IDs.
  > Responsibility: Actionability ‚Äî identify missing tests.
  > Verification: Uncovered IDs listed in report.

- **META_TEST_GENERATION**: Compiler Script MUST extract testable fixtures to `tests/specs/` mirroring the L1-L3 hierarchy.
  > Responsibility: Synchronization ‚Äî tests are derived directly from specs.
  > Verification: `tests/specs/{layer}/{item}.py` matches spec structure.
  

- **WORKFLOW_VERIFICATION**: Script MUST verify L3 `[workflow]` items using state transition fixtures.
  > Responsibility: Integration Logic ‚Äî prove sequences work end-to-end.
  > Verification: Tests execute workflow steps and assert final state.
  

- **TEST_GENERATION**: Agent MUST generate tests for uncovered L3 fixtures.
  > Responsibility: Completeness ‚Äî close coverage gaps.
  > Verification: Test file created for each uncovered L3 item.

- **HUMAN_APPROVAL_TEST**: Agent MUST request approval before saving generated tests.
  > Responsibility: Quality gate ‚Äî human reviews test design.
  > Verification: notify_user called before file write.

- **EXECUTION_REPORT**: Script MUST report PASS/FAIL counts by test type.
  > Responsibility: Transparency ‚Äî summarize test results.
  > Verification: Report includes SCRIPT and PROMPT results.

- **RESULT_EVALUATION**: Agent SHOULD analyze failures and propose fixes.
  > Responsibility: Actionability ‚Äî convert failures to work items.
  > Verification: Idea generated for failing tests.

- **TEST_GRANULARITY**: Script AND Agent tests MUST be organized at H2 (##) level spec granularity.
  > Responsibility: Maintainability ‚Äî one test per H2 section for easy updates.
  > Naming: `test_{item_id}.*` or `answer_key_{item_id}.md` (extension per project framework).
  > Verification: Each test artifact maps to exactly one `## [...]` spec section.

---

## CONTRACTS.CERTIFICATION

- **ANSWER_KEY_LOCATION**: Script MUST place answer keys in `tests/specs/agent/` and `tests/specs/decision/`.
  > Responsibility: Organization ‚Äî keep tests near their spec counterparts.
  > Verification: `answer_key_l3_*.md` found in `tests/specs/decision/`.
  

- **ANSWER_KEY_FORMAT**: Agent MUST generate answer keys as Markdown files with `<!-- ANSWER_START -->` and `<!-- ANSWER_END -->` markers.
  > Responsibility: Parsing ‚Äî ensure automated scripts can extract test answers.
  > Verification: `validate.py` AND `test_coverage.py` check for these markers.
  

- **VERIFY_SPEC_ANNOTATION**: Agent MUST include `@verify_spec_id("SPEC_ID")` annotation per test item.

  > Responsibility: Traceability ‚Äî enable coverage calculation for both agent and script tests.
  > Verification: All test items contain `@verify_spec_id` with valid spec ID.
  

- **ERROR_PRONE_FOCUS**: Agent MUST design tests targeting error-prone usage patterns.
  > Responsibility: Quality ‚Äî cover realistic failure scenarios users encounter.
  > Verification: Tests include edge cases and common misuse patterns.
  

- **COMBINE_QUESTION_PAPER**: Script MUST combine all answer_key files and strip answers to generate `question_paper.md`.
  > Responsibility: Assessment ‚Äî produce unified exam from individual answer keys.
  > Verification: `tests/specs/agent/question_paper.md` contains all items with blank answers.
  

- **REALISTIC_CONTEXT**: Agent MUST use realistic Context/Expectation content matching actual project inputs.
  > Responsibility: Relevance ‚Äî test scenarios must reflect real user/script inputs, not placeholders.
  > Verification: answer_key files contain concrete, project-specific examples.
  

- **CONTEXTUAL_SCENARIO**: Vibespec MUST analyze project context to generate and execute a relevant End-to-End Scenario.
  > Responsibility: Relevance ‚Äî prove toolchain works on *this* project.
  > Verification: Generated scenario matches project domain (e.g., User vs. Order).
  
---

## CONTRACTS.MAINTENANCE

- **BUG_RCA**: On `vibespec bug`, Agent MUST trace failures recursively from L3 to L0 to find the root cause spec item.
  > Responsibility: Depth ‚Äî find the true origin.
  > Verification: RCA trace log shows upward traversal.
  

- **RECURSIVE_FIX**: Agent MUST verify proposed spec fixes against parent layers (Upward) before cascading changes (Downward).
  > Responsibility: Integrity ‚Äî prevent local fixes from breaking global contracts.
  > Verification: Fix proposal includes parent compliance check.
  

- **DELETION_JUSTIFICATION**: Agent MUST document the reason for any L1-L3 item deletion and request review.
  > Responsibility: Safety ‚Äî prevent accidental regression or scope creep (deletion is scope change).
  > Verification: User approval prompt contains "Motivation: [reason]" for deleted items.
  
---

## CONTRACTS.RELOAD

- **RELOAD_TRIGGER**: When user inputs `vibespec reload`, Agent MUST re-read SKILL.md.
  > Responsibility: Hot-reload ‚Äî apply skill changes without restarting session.
  > Verification: Agent confirms SKILL.md re-loaded after trigger.
  

---

## CONTRACTS.TEMPLATE_GENERATION

- **USE_TEMPLATES**: Agent MUST use templates from `src/assets/specs/` when generating files.
  > Responsibility: Consistency ‚Äî ensure uniform formatting across all generated specs.
  > Verification: Generated files match template structure.
  

- **TEMPLATE_FILES**: Templates MUST include: IDEA_TEMPLATE.md, L0-VISION.md, L1-CONTRACTS.md, L2-ARCHITECTURE.md, L3-IMPLEMENTATION.md.
  > Responsibility: Completeness ‚Äî provide templates for all spec types.
  > Verification: All template files exist in `src/assets/specs/`.
  

---

## CONTRACTS.STARTUP_MENU

- **INTERACTIVE_START**: When user runs `vibespec` (no args), Agent MUST display capabilities menu and wait for input.
  > Responsibility: Control ‚Äî prevent accidental execution of pending workloads.
  > Verification: Agent outputs usage help and stops execution.
  

- **FIRST_RUN_COMPREHENSION**: On first `vibespec` invocation, Agent MUST read all L0-L3 specs before executing.
  > Responsibility: Context ‚Äî ensure deep project understanding before action.
  > Verification: Agent summarizes project understanding before proceeding.
  

---

## CONTRACTS.AUTOMATE_MODE

- **AUTOMATE_TRIGGER**: When user inputs `vibespec automate`, Agent MUST enter automate mode.
  > Responsibility: Efficiency ‚Äî enable hands-off batch processing.
  > Verification: Agent processes all ideas without human approval gates.
  

- **AUTO_ACCEPT**: In automate mode, Agent MUST auto-accept own suggestions.
  > Responsibility: Speed ‚Äî skip approval delays for routine changes.
  > Verification: No notify_user calls with BlockedOnUser=true.
  

- **AUTO_FIX_WARNINGS**: In automate mode, Agent MUST auto-fix validation warnings.
  > Responsibility: Completeness ‚Äî resolve all cascade warnings automatically.
  > Verification: Validation passes with 0 warnings after automate completes.
  

- **BUILD_BEFORE_TEST**: In automate mode, Agent MUST execute Build phase before Test phase.
  > Responsibility: Validity ‚Äî tests must run against latest artifacts.
  > Verification: Workflow sequence is Refine ‚Üí Validate ‚Üí Compile ‚Üí Build ‚Üí Test.

<a id='source-l2-architecture'></a>
# Source: L2-ARCHITECTURE.md
RELIABILITY: AUTHORITATIVE
---

# L2: Vibespec Architecture

> **Subject**: Role (Active) | Component (Passive)
> - Role: Observes / Decides / Acts (Agent-driven)
> - Component: Input / Output (Script-driven)
> - Decision: Abstract L3 logic for Roles
> - Heading levels indicate hierarchy: H2 = Top, H3 = Subsystem, H4 = Leaf

---

## ROLES

> Active entities: observe, decide, act

### ROLES.SPEC_MANAGEMENT

> Specification lifecycle management

#### ARCHITECT

**Role**: Plans spec changes

- **Observes**: Sorted ideas, current spec state, layer definitions
- **Decides**: Target layer, decomposition strategy, conflict resolution
- **Acts**: Creates change proposals, requests approval

#### REVIEWER

**Role**: Audits change quality

- **Observes**: Change proposals, parent layer, existing content
- **Decides**: Internal consistency, traceability coverage, contradiction detection
- **Acts**: Approves or rejects, presents to user

 #### QUALITY_AUDITOR
 
 **Role**: Deep quality inspection with role-first assessment
 
 - Observes: Spec content, alignment rules
 - Decides: Compliance with pillars, quality before validation
 - Acts: Flags non-compliance, assesses via role evaluation FIRST

 #### CONSISTENCY_CHECKER
 
 **Role**: Logical consistency and cascade check
 
 - Observes: Parent/Child Specs
 - Decides: Omissions, redundancies, downstream impact
 - Acts: Blocks invalid edits, evaluates cascade impact

 #### PROCESS_ENFORCER
 
 **Role**: Enforces workflow constraints
 
 - Observes: Action sequence, approval states
 - Decides: Whether action violates process rules
 - Acts: Blocks multi-layer edits, enforces human review gates

#### TRACEABILITY_GUARDIAN

**Role**: Ensures traceability chain integrity

- **Observes**: All references, parent-child relationships, coverage metrics
- **Decides**: Orphan detection, dangling refs, staleness detection
- **Acts**: Flags violations, generates fix ideas

### ROLES.USER_INTERACTION

> User interaction roles

#### USER_LIAISON

**Role**: Communicates with human

- **Observes**: Pending approvals, findings, proposals
- **Decides**: Information format, urgency level
- **Acts**: Calls notify_user, waits for response

#### BOOTSTRAP_AGENT

**Role**: Initializes new projects

- **Observes**: Filesystem state, user input
- **Decides**: Whether bootstrap needed, scope formulation
- **Acts**: Prompts for scope, converts to SHALL/SHALL_NOT, creates L0

 #### ONBOARDING_ASSISTANT
 
 **Role**: Guides new users
 
 - Observes: Empty project state
 - Decides: Engagement strategy
 - Acts: Invites brainstorming

### ROLES.AUTOMATION

> Automation enhancement roles

#### RECOVERY_AGENT

**Role**: Handles failures and rejections

- **Observes**: Error count, rejection signals, system state
- **Decides**: Retry vs revert, whether to change approach
- **Acts**: Attempts fix (max 3), reverts on failure

#### INSIGHT_MINER

**Role**: Extracts specs from conversation

- **Observes**: Current conversation context
- **Decides**: Key decisions, architectural shifts, new requirements
- **Acts**: Creates idea files, requests approval

#### PATTERN_SCOUT

**Role**: Identifies automation opportunities

- **Observes**: Agent action history, repetitive patterns
- **Decides**: Script-worthiness (frequency, determinism)
- **Acts**: Proposes new scripts via idea pipeline

#### RELOAD_HANDLER

**Role**: Reloads skill definitions

- **Observes**: User `vibespec reload` command
- **Decides**: Whether SKILL.md changed
- **Acts**: Re-reads SKILL.md, confirms reload to user

#### AUTOMATE_CONTROLLER

**Role**: Controls automate mode execution

- **Observes**: User `vibespec automate` command, pending ideas, validation warnings
- **Decides**: Processing order, warning fix strategy
- **Acts**: Processes ideas, auto-accepts suggestions, auto-fixes warnings

#### TEST_VERIFIER

**Role**: LLM-driven test execution

- **Observes**: L3 prompt items, test fixtures
- **Decides**: Pass/Fail based on behavior, Mocking strategy
- **Acts**: Generates mock-based test code, reports result with evidence

#### TEST_DESIGNER

**Role**: Generates test cases from specs

- **Observes**: L3 fixtures, edge cases, error cases, existing test coverage
- **Decides**: Test strategy, boundary scenarios, missing coverage areas
- **Acts**: Generates test code with `@verify_spec` decorators, requests approval

> Rationale: Script implementation would be prohibitively complex due to semantic understanding requirements.

#### IMPLEMENTER

**Role**: Synchronizes project artifacts with specs

- **Observes**: `vibespec-full.md`, `vibespec.yaml`, existing source code in `src/`
- **Decides**: Gap analysis (MISSING/OUTDATED/ORPHAN), refactor vs rewrite strategy
- **Acts**: Generates gap report, applies incremental changes, requests approval for large rewrites

---

## COMPONENTS

> Passive entities: receive input, produce output

### COMPONENTS.COMPILER_PIPELINE

> Multi-stage compilation pipeline

#### SCANNER

**Component**: Finds spec files

- Input: `path: string`
- Output: `File[]`

#### PARSER

**Component**: Extracts frontmatter and body

- Input: `file: File`
- Output: `{metadata, body}`

 #### SECTION_PARSER
 
 **Component**: Identifying sections
 
 - Input: `lines: string[]`
 - Output: `Section[]`
 

#### VALIDATOR

**Component**: Executes all validation rules

- Input: `specs: ParsedSpec[]`
- Output: `ValidationResult`

#### ASSEMBLER

**Component**: Merges specs into document

- Input: `specs: ParsedSpec[]`
- Output: `Document`

### COMPONENTS.VALIDATOR_CORE

> Rule-based validation engine

#### RULE_ENGINE

**Component**: Executes validation rules

- Input: `rules: Rule[], specs: Spec[]`
- Output: `Violation[]`

#### CUSTOM_RULES_LOADER

**Component**: Loads project custom rules

- Input: `specs_dir: Path`
- Output: `Rule[]`

#### RESPONSIVENESS_CHECKER

**Component**: Validates coverage

- Input: `graph: SpecGraph`
- Output: `CoverageResult`

### COMPONENTS.IDEAS_PROCESSOR

> Ideas processing pipeline

#### BATCH_READER

**Component**: Reads all idea files

- Input: `path: string`
- Output: `Idea[]`

#### SORTER

**Component**: Sorts by timestamp

- Input: `ideas: Idea[]`
- Output: `Idea[]` (sorted)

#### ARCHIVER

**Component**: Moves processed ideas to archive

- Input: `ideas: Idea[]`
- Output: `void`

### COMPONENTS.SCRIPTS

> Standalone automation tools
 
 #### SKILL_LOADER
 
 **Component**: Loads SKILL.md
 
 - Input: `path`
 - Output: `SkillDef`

#### VALIDATE_SCRIPT

**Script**: `scripts/validate.py`

- Input: `specs_path`
- Output: `ValidationResult`

#### COMPILE_SCRIPT

**Script**: `scripts/compile.py`

- Input: `specs_path, output_path`
- Output: `Document`

 #### INIT_SCRIPT
 
 **Script**: `scripts/init.py`
 
 - Input: `scope`
 - Output: `L0-VISION.md`, `vibespec.yaml`
 
 

#### BUILD_SCRIPT

**Script**: `scripts/build.py`

- Input: `vibespec.yaml`
- Output: `BuildReport`, `Prompt`

### COMPONENTS.TRIGGER_ROUTER

> Trigger routing system

#### COMMAND_ROUTER

**Component**: Parses invocation command

- Input: `input: string`
- Output: `{command, args}`

#### WORKFLOW_DISPATCHER

**Role**: Selects handler

- Input: `parsed: ParsedCommand, fs_state: FSState`
- Output: `Handler`
- Logic:
  1. Args ‚Üí Capture workflow
  2. Ideas exist ‚Üí Ideas workflow
  3. SKILL.md exists ‚Üí Validation workflow
  4. Otherwise ‚Üí Bootstrap workflow

### COMPONENTS.REPORTING

> Report generation

#### ERROR_PRINTER

**Component**: Formats errors

- Input: `errors: Error[]`
- Output: `string`

#### DECISION_ANSWER_KEY_GENERATOR

**Component**: Generates answer keys for L3 Decisions.

**Type**: Script

**Implements**:
- 

**Testing**: `tests/specs/decision/`

#### DIFF_VIEWER

**Component**: Shows differences

- Input: `before: Spec, after: Spec`
- Output: `string`

### COMPONENTS.QUALITY

> Quality assurance

#### TERM_CHECKER

**Component**: Validates terminology

- Input: `content: string`
- Output: `VocabResult`

#### ASSERTION_CHECKER

**Component**: Scans for RFC2119 keywords

- Input: `spec: Spec`
- Output: `AssertionResult`

 #### LINT_CHECKER
 
 **Component**: Checks annotation rules
 
 - Input: `spec: Spec`
 - Output: `LintResult`

 #### PURITY_CHECKER
 
 **Component**: Enforces type purity
 
 - Input: `spec: Spec`
 - Output: `PurityResult`

 #### SCRIPT_SCANNER
 
 **Component**: Scans scripts for safety
 
 - Input: `script: Script`
 - Output: `SafetyResult`

 #### NOTATION_CHECKER
 
 **Component**: Enforces formal syntax
 
 - Input: `spec: Spec`
 - Output: `NotationResult`
 
 

### COMPONENTS.INFRASTRUCTURE
 
 > Low-level system operations
 
 #### ATOMIC_WRITER
 
 **Component**: Safe file operations
 
 - Input: `path, content`
 - Output: `void`
 
 

> Metrics collection

#### STATS_COLLECTOR

**Component**: Aggregates all metrics

- Input: `specs: Spec[]`
- Output: `{itemCounts, ratios, fanout, wordCounts}`

#### COVERAGE_ANALYZER

**Component**: Collects testable specs and computes coverage

- Input: `specs_dir: Path, tests_dir: Path`
- Output: `CoverageReport{l1_coverage, l3_coverage, uncovered_ids[]}`
- Logic:
  1. Extract L1 assertions (MUST/SHOULD/MAY) from specs
  2. Extract L3 fixtures from `[interface]`/`[decision]`/`[algorithm]`
  3. Scan tests for `@verify_spec("ID")` or YAML `id:` matches
  4. Compute coverage percentages

#### TEST_EXECUTOR

**Component**: Runs test suites

- Input: `tests_dir: Path, env: MOCK|REAL`
- Output: `ExecutionResult{passed, failed, skipped}`

#### TEST_REPORTER

**Component**: Formats test results

- Input: `coverage: CoverageReport, execution: ExecutionResult`
- Output: `string` (formatted report)

#### ADAPTER_FACTORY

**Component**: Creates MOCK or REAL adapters for test execution

- Input: `interface_id: string, env: MOCK|REAL`
- Output: `Adapter`
- Logic:
  1. If env == MOCK ‚Üí Return MockAdapter (uses L3 Fixtures)
  2. If env == REAL ‚Üí Return RealAdapter (imports user implementation)
  3. If REAL adapter not found ‚Üí Return SkipAdapter

#### WORKFLOW_TEST_EXECUTOR

**Component**: Executes workflow (integration) tests

- Input: `workflow_id: string, env: MOCK|REAL`
- Output: `WorkflowResult{passed, failed, steps_executed[]}`
- Logic:
  1. Load workflow definition from L3
  2. Execute each step sequentially
  3. Role steps use mocked output (ROLE_ALWAYS_MOCK)
  4. Component steps use env-based adapter

#### BUILDER

**Component**: Orchestrates spec-to-implementation transformation

- Input: `compiled_spec: Path, skills: string[]`
- Output: `UpdateStatus`

#### CERTIFICATION_ENGINE

**Component**: Produces certification artifacts

- Input: `specs: Spec[]`
- Output: `answer_key_l1.md, answer_key_l3.md, question_paper.md`
- Standards:
  - Each item in answer_key files MUST include `@verify_spec_id("SPEC_ID")`
  - Tests MUST focus on error-prone usage patterns

#### TEMPLATE_LOADER

**Component**: Loads spec templates

- Input: `template_dir: Path`
- Output: `templates: Map<LayerType, Template>`

#### SCENARIO_DRIVER

**Component**: Executes end-to-end scenarios

- Input: `scenario_path: Path`
- Output: `Pass | Fail`

<a id='source-l3-runtime'></a>
# Source: L3-RUNTIME.md
RELIABILITY: AUTHORITATIVE
---

# L3: Vibespec Runtime

> **Purpose**: Capture complex/error-prone implementation details for testability
> 
> **Content Types**: `[interface]` | `[decision]` | `[algorithm]` | `[workflow]`

**Item Type Definitions**

| Type | Tag | Associated Entity | Purpose | Content Requirement |
|------|-----|-------------------|---------|---------------------|
| **Interface** | `[interface]` | **Component** | Define system boundaries and function signatures. | Typed code block (TypeScript/Python), Fixtures table. |
| **Decision** | `[decision]` | **Role** | Capture complex logic, human judgment, or policy rules. | Logic Table, Checklist, or Decision Tree. Fixtures: Situation/Decision/Rationale. |
| **Algorithm** | `[algorithm]` | **Component** | Describe deterministic computational steps. | Pseudocode or Flowchart. |
| **Workflow** | `[workflow]` | **Component** | Orchestrate Components and Roles into end-to-end processes. | Ordered Steps list with Actor assignment. |

---

## [interface] SCANNER

```code
interface Scanner {
  scan(path: string): File[]
}
```

---

## [interface] PARSER

```code
interface Parser {
  parse(file: File): {metadata: Frontmatter, body: string}
}
```

---

## [interface] VALIDATOR

```code
interface Validator {
  validate(specs: ParsedSpec[]): ValidationResult
}

interface ValidationResult {
  errors: Violation[]
  warnings: Violation[]
}
```

---

## [interface] ASSEMBLER

```code
interface Assembler {
  assemble(specs: ParsedSpec[]): Document
}
```

---

## [interface] RULE_ENGINE

```code
interface RuleEngine {
  execute(rules: Rule[], specs: Spec[]): Violation[]
}
```

---

## [interface] RESPONSIVENESS_CHECKER

```code
interface ResponsivenessChecker {
  check(graph: SpecGraph): CoverageResult
}
```

---

## [interface] BATCH_READER

```code
interface BatchReader {
  read(path: string): Idea[]
}
```

---

## [interface] SORTER

```code
interface Sorter {
  sort(ideas: Idea[]): Idea[]
}
```

---

## [decision] LAYER_CLASSIFICATION

**Rules**:
| Priority | Signal | Layer |
|----------|--------|-------|
| 1 | RFC2119 (MUST/SHOULD/SHALL/MAY) | L1 |
| 2 | Architecture entity (Role/Component) | L2 |
| 3 | Algorithm description | L3 |
| 4 | User expectation | L0 |
| 5 | Default | L0 + clarify |

---

## [decision] CONFLICT_RESOLUTION

**Rules**:
| Conflict Type | Action |
|--------------|--------|
| Different timestamps | Latest wins |
| Same timestamp | User decides |
| Mergeable | Merge + confirm |

---

## [decision] RETRY_LOGIC

**Rules**:
| Condition | Action |
|-----------|--------|
| Validation Error | Run auto-fix, then re-validate |
| Compile Error | Stop and report to user |
| Human Reject | Revert change, ask for guidance |

---

## [decision] TYPE_PURITY_CHECK

**Rules**:
| Signal | Type |
|--------|------|
| Semantic, context, judgment | Agent |
| Deterministic, transform | Script |

| Result | Action |
|--------|--------|
| Pure Agent | Pass |
| Pure Script | Pass |
| Mixed | Violation |

---

## [decision] LAYER_REVIEW_CRITERIA

**Checklists by Layer**:
| Layer | Focus | Key Questions |
|-------|-------|---------------|
| L0 | Vision | Does it align with project philosophy? |
| L1 | Contracts | Is it testable? RFC2119 keywords? |
| L2 | Architecture | Agent vs Script? Max 3 refs? |
| L3 | Implementation | Fixtures complete? Type signature? |

## [algorithm] COVERAGE_VALIDATION

```pseudocode
function validate_coverage(specs: Spec[]) -> Violation[]:
  violations = []
  graph = build_ref_graph(specs)
  
  for item in graph.upstream_items():
    downstream = graph.get_downstream(item.id)
    
    if len(downstream) == 0:
      violations.append(OrphanViolation(item.id))
    
    if len(downstream) > 7:
      violations.append(FanoutViolation(item.id))
  
  return violations
```

---

## [interface] COVERAGE_ANALYZER

```code
interface CoverageAnalyzer {
  analyze(specs_dir: Path, tests_dir: Path): CoverageReport
}

interface CoverageReport {
  l1_coverage: number  // 0.0 - 1.0
  l3_coverage: number  // 0.0 - 1.0
  uncovered_ids: string[]
}
```

---

## [interface] TEST_EXECUTOR

```code
interface TestExecutor {
  run(tests_dir: Path, env: 'MOCK' | 'REAL'): ExecutionResult
}

interface ExecutionResult {
  passed: number
  failed: number
  skipped: number
  errors: number
}

type TestResultState = 'PASS' | 'FAIL' | 'SKIP' | 'ERROR'
```

---

## [interface] TEST_REPORTER

```code
interface TestReporter {
  format(coverage: CoverageReport, execution: ExecutionResult): string
}
```

---

## [interface] ADAPTER_FACTORY

```code
interface AdapterFactory {
  get(interface_id: string, env: 'MOCK' | 'REAL'): Adapter
}

type Adapter = MockAdapter | RealAdapter | SkipAdapter

interface MockAdapter {
  type: 'mock'
  execute(input: any): FixtureResult
}

interface RealAdapter {
  type: 'real'
  execute(input: any): any
}

interface SkipAdapter {
  type: 'skip'
  reason: string
}
```

---

## [interface] BUILDER

```code
interface Builder {
  build(compiled_spec: Path, skills: string[]): BuildResult
}

interface BuildResult {
  status: 'SUCCESS' | 'PARTIAL' | 'CONFLICT' | 'ERROR'
  updates: string[]
  warnings: string[]
}
```

---

## [interface] SECTION_PARSER

```code
interface SectionParser {
  parse(content: string): Section[]
}
```

## ID" | [{tag: "system", id: "ID"}] | Normal |
| "## ID" | [{tag: null, id: "ID"}] | Edge |
| "" | [] | Edge |

---

## [interface] CUSTOM_RULES_LOADER

```code
interface CustomRulesLoader {
  load(specsDir: Path): Rule[]
}
```

---

## [interface] ARCHIVER

```code
interface Archiver {
  archive(ideas: Idea[]): void
}
```

---

## [interface] SKILL_LOADER

```code
interface SkillLoader {
  load(path: Path): SkillDef
}
```

---

## [interface] INIT_SCRIPT

```code
interface InitScript {
  init(projectDir: Path): InitResult
  generateConfig(): Path
}
```

---

## [interface] VALIDATE_SCRIPT

```code
interface ValidateScript {
  validate(specsDir: Path): ValidationResult
}
```

---

## [interface] COMPILE_SCRIPT

```code
interface CompileScript {
  compile(specsDir: Path, output: Path): void
}
```

---

## [interface] BUILD_SCRIPT

```code
interface BuildScript {
  build(config: Path): BuildReport
}
```

---

## [interface] COMMAND_ROUTER

```code
interface CommandRouter {
  route(command: string): Handler
}
```

---

## [interface] WORKFLOW_DISPATCHER

```code
interface WorkflowDispatcher {
  dispatch(trigger: Trigger): void
}
```

---

## [interface] LINT_CHECKER

```code
interface LintChecker {
  check(spec: Spec): LintResult
}
```

---

## [interface] ASSERTION_CHECKER

```code
interface AssertionChecker {
  check(spec: Spec): AssertionResult
}
```

---

## [interface] NOTATION_CHECKER

```code
interface NotationChecker {
  check(spec: Spec): NotationResult
}
```

---

## [interface] TERM_CHECKER

```code
interface TermChecker {
  check(spec: Spec, vocab: Vocabulary): TermResult
}
```

---

## [interface] PURITY_CHECKER

```code
interface PurityChecker {
  check(spec: Spec): PurityResult
}
```

---

## [interface] SCRIPT_SCANNER

```code
interface ScriptScanner {
  scan(spec: Spec): ScriptRef[]
}
```

---

## [interface] ERROR_PRINTER

```code
interface ErrorPrinter {
  print(errors: Violation[]): string
}
```

---

## [interface] DIFF_VIEWER

```code
interface DiffViewer {
  diff(before: Spec, after: Spec): DiffResult
}
```

---

## [interface] DECISION_ANSWER_KEY_GENERATOR

```code
interface DecisionAnswerKeyGenerator {
  generate(decision: Decision): AnswerKeyFile
}
```

---

## [interface] ATOMIC_WRITER

```code
interface AtomicWriter {
  write(path: Path, content: string): void
}
```

---

## [interface] STATS_COLLECTOR

```code
interface StatsCollector {
  collect(specs: Spec[]): Stats
}
```

---

## [decision] TEST_DESIGNER

**Decision Logic**:
1. Analyze L3 fixtures for testable scenarios
2. Determine test strategy (unit/integration)
3. Generate test code with `@verify_spec` decorators

---

## [decision] TEST_VERIFIER

**Decision Logic**:
1. Run generated tests
2. Compare results to expected outcomes
3. Report pass/fail with evidence

---

## [decision] IMPLEMENTER

**Decision Logic**:
1. Perform gap analysis
2. Decide refactor vs rewrite
3. Apply incremental changes

---

## [decision] PATTERN_SCOUT

**Decision Logic**:
1. Analyze code for repeated patterns
2. Identify abstraction opportunities
3. Suggest refactoring

---

## [decision] INSIGHT_MINER

**Decision Logic**:
1. Analyze spec evolution
2. Identify trends and issues
3. Generate insights

---

## [decision] QUALITY_AUDITOR

**Decision Logic**:
1. Check spec quality metrics
2. Compare to thresholds
3. Report violations

---

## [decision] CONSISTENCY_CHECKER

**Decision Logic**:
1. Compare related specs
2. Detect contradictions
3. Flag inconsistencies

---

## [decision] USER_LIAISON

**Decision Logic**:
1. Receive user requests
2. Route to appropriate workflow
3. Report results

---

## [decision] BOOTSTRAP_AGENT

**Decision Logic**:
1. Check project state
2. Initialize if needed
3. Report status

---

## [decision] ONBOARDING_ASSISTANT

**Decision Logic**:
1. Assess user familiarity
2. Provide appropriate guidance
3. Offer examples

---

## [decision] RELOAD_DECISION

**Decision Logic**:
1. Receive `vibespec reload` command
2. Re-read SKILL.md from disk
3. Confirm reload to user

---

## [workflow] AUTOMATE_WORKFLOW

**Steps**:
1. Trigger: `vibespec automate`
2. Scan: `specs/ideas/` -> `pending_ideas[]`
3. Loop for each `idea` in `pending_ideas`:
   a. **[Agent: INSIGHT_MINER]** Refinement: Breakdown idea to L1/L2/L3
   b. **[Script: VALIDATOR]** Validation: Run `python validate.py`
   c. **[Agent: PROCESS_ENFORCER]** Oversight: Check for cascade warnings
   d. **[Agent: IMPLEMENTER]** Fix: Resolve warnings
4. **[Script: COMPILER]** Compile: Run `python compile.py`
5. **[Script: BUILDER]** Build: Sync artifacts via `vibespec build`
6. **[Script: TEST_RUNNER]** Test: Run `python test.py`
7. Final: **[Script: CLI]** Report success

---

## [interface] TEMPLATE_LOADER_INTERFACE

```code
interface TemplateLoader {
  load(templateDir: string): Map<LayerType, Template>
}
```

---

## [interface] CERTIFICATION_ENGINE_INTERFACE

```code
interface CertificationEngine {
  generateAnswerKey(spec: Spec): AnswerKeyFile
  combineQuestionPaper(keys: AnswerKeyFile[]): QuestionPaper
}
```

---

## [decision] PROCESS_ENFORCER_DECISION

**Decision Logic**:
1. Check if edit spans multiple layers (L1 + L2)
2. Check if persistent action (write) has prior human approval
3. Block if violation detected

---

## [algorithm] SCENARIO_GENERATION

**Logic**:
1. Scan project `src/` to identify domain (e.g., Models, APIs).
2. Scan `specs/` to identify recent changes or core features.
3. Construct E2E workflow: `Idea -> Spec -> Impl -> Verify`.
4. Output: `[workflow] PROJECT_E2E_SCENARIO`

```code
function generateScenario(project: ProjectContext): Workflow
```

---

## [interface] SCENARIO_DRIVER_INTERFACE

```code
interface ScenarioDriver {
  run(workflow: Workflow): Result
}
```

---

## [workflow] FULL_WORKFLOW

**Purpose**: End-to-end test covering all Roles and Components in a realistic project scenario.

**Steps - Init Phase**:
1. `COMMAND_ROUTER.route("init")` ‚Üí InitCommand
2. `TEMPLATE_LOADER.load()` ‚Üí Templates  
3. `BOOTSTRAP_AGENT.initialize()` ‚Üí ProjectStructure (mocked)

**Steps - Spec Phase**:
4. `SCANNER.scan("specs/")` ‚Üí File[]
5. `PARSER.parse(files)` ‚Üí Spec[]
6. `CUSTOM_RULES_LOADER.load()` ‚Üí Rules
7. `RULE_ENGINE.apply(specs, rules)` ‚Üí EnrichedSpecs
8. `VALIDATOR.validate(specs)` ‚Üí ValidationResult
9. `TERM_CHECKER.check(specs)` ‚Üí TermResult
10. `ASSERTION_CHECKER.check(specs)` ‚Üí AssertResult

**Steps - Compile Phase**:
11. `ASSEMBLER.assemble(specs)` ‚Üí CompiledSpec
12. `SORTER.sort(specs)` ‚Üí OrderedSpecs
13. `BATCH_READER.read(files)` ‚Üí BatchContent
14. `RESPONSIVENESS_CHECKER.check()` ‚Üí ResponsivenessResult
15. `STATS_COLLECTOR.collect(specs)` ‚Üí Stats
16. `SUMMARY_GENERATOR.generate(stats)` ‚Üí Summary
17. `DIFF_VIEWER.diff(old, new)` ‚Üí DiffResult
18. `ERROR_PRINTER.print(errors)` ‚Üí FormattedErrors

**Steps - Review Phase (Role)**:
19. [Role] `ARCHITECT.review(compiled)` ‚Üí ReviewResult (mocked)
20. [Role] `REVIEWER.approve(compiled)` ‚Üí Approval (mocked)
21. [Role] `TRACEABILITY_GUARDIAN.verify(refs)` ‚Üí TraceResult (mocked)
22. [Role] `CONSISTENCY_CHECKER.check(specs)` ‚Üí ConsistencyResult (mocked)
23. [Role] `QUALITY_AUDITOR.audit(specs)` ‚Üí QualityResult (mocked)

**Steps - Build Phase**:
24. `BUILDER.build(approved)` ‚Üí BuildResult
25. [Role] `IMPLEMENTER.implement(approved)` ‚Üí Implementation (mocked)
26. [Role] `PATTERN_SCOUT.scan(code)` ‚Üí Patterns (mocked)
27. [Role] `INSIGHT_MINER.analyze(patterns)` ‚Üí Insights (mocked)

**Steps - Test Phase**:
28. `COVERAGE_ANALYZER.analyze(tests)` ‚Üí CoverageResult
29. `ADAPTER_FACTORY.create(iface, MOCK)` ‚Üí Adapter
30. `TEST_EXECUTOR.run(tests, MOCK)` ‚Üí TestResult
31. `WORKFLOW_TEST_EXECUTOR.run(workflow, MOCK)` ‚Üí WorkflowResult
32. `TEST_REPORTER.format(result)` ‚Üí Report
33. [Role] `TEST_DESIGNER.design(gaps)` ‚Üí NewTests (mocked)
34. [Role] `TEST_VERIFIER.verify(results)` ‚Üí Verification (mocked)

**Steps - Certification Phase**:
35. `CERTIFICATION_ENGINE.generate(specs)` ‚Üí AnswerKeys
36. `SCENARIO_DRIVER.run(workflow)` ‚Üí ScenarioResult
37. `ARCHIVER.archive(approved)` ‚Üí ArchiveResult

**Steps - User Interaction (Role)**:
38. [Role] `USER_LIAISON.report(summary)` ‚Üí UserReport (mocked)
39. [Role] `ONBOARDING_ASSISTANT.guide(user)` ‚Üí OnboardingResult (mocked)

**Steps - Recovery (Role)**:
40. [Role] `RECOVERY_AGENT.recover(error)` ‚Üí RecoveryResult (mocked)
41. [Role] `RELOAD_HANDLER.reload(context)` ‚Üí ReloadResult (mocked)

**Steps - Script Execution**:
42. `VALIDATE_SCRIPT.validate(specs)` ‚Üí ValidationResult
43. `COMPILE_SCRIPT.compile(specs)` ‚Üí CompiledDoc
44. `BUILD_SCRIPT.build(spec)` ‚Üí BuildOutput
45. `WORKFLOW_DISPATCHER.dispatch(trigger)` ‚Üí WorkflowResult
46. [Role] `AUTOMATE_CONTROLLER.orchestrate(steps)` ‚Üí AutomationResult (mocked)
47. [Role] `PROCESS_ENFORCER.enforce(action)` ‚Üí EnforceResult (mocked)

---

## [workflow] BOOTSTRAP_WORKFLOW

**Purpose**: Initialize project structure and configuration from templates.

**Steps**:
1. `COMMAND_ROUTER.route("init")` ‚Üí InitCommand
2. `TEMPLATE_LOADER.load()` ‚Üí Templates
3. `BOOTSTRAP_AGENT.initialize()` ‚Üí ProjectStructure
4. `SKILL_LOADER.load()` ‚Üí Skills

---

## [workflow] IDEA_TO_SPEC_WORKFLOW

**Purpose**: Ingest raw ideas and refine them into formal specifications.

**Steps**:
1. `BATCH_READER.read("ideas/")` ‚Üí BatchContent
2. `SORTER.sort(content)` ‚Üí OrderedIdeas
3. [Role] `INSIGHT_MINER.analyze(ideas)` ‚Üí Insights
4. [Role] `ARCHITECT.design(insights)` ‚Üí DraftSpecs
5. `ARCHIVER.archive(ideas)` ‚Üí ArchiveResult

---

## [workflow] SPEC_VALIDATION_WORKFLOW

**Purpose**: Rigorous validation of specification integrity, quality, and compliance.

**Steps**:
1. `SCANNER.scan("specs/")` ‚Üí File[]
2. `PARSER.parse(files)` ‚Üí Spec[]
3. `CUSTOM_RULES_LOADER.load()` ‚Üí Rules
4. `RULE_ENGINE.apply(specs, rules)` ‚Üí EnrichedSpecs
5. `VALIDATOR.validate(specs)` ‚Üí ValidationResult
6. `TERM_CHECKER.check(specs)` ‚Üí TermResult
7. `ASSERTION_CHECKER.check(specs)` ‚Üí AssertResult

---

## [workflow] COMPILATION_WORKFLOW

**Purpose**: Compile specs into authoritative documentation and build deliverables.

**Steps**:
1. `ASSEMBLER.assemble(specs)` ‚Üí CompiledSpec
2. `RESPONSIVENESS_CHECKER.check()` ‚Üí ResponsivenessResult
3. `SUMMARY_GENERATOR.generate(stats)` ‚Üí Summary
4. `DIFF_VIEWER.diff(old, new)` ‚Üí DiffResult
5. `COMPILE_SCRIPT.compile(specs)` ‚Üí CompiledDoc
6. `BUILD_SCRIPT.build(spec)` ‚Üí BuildOutput

---

## [workflow] TESTING_CERTIFICATION_WORKFLOW

**Purpose**: Verify system correctness and certify compliance.

**Steps**:
1. `CERTIFICATION_ENGINE.generate(specs)` ‚Üí AnswerKeys
2. `COVERAGE_ANALYZER.analyze(tests)` ‚Üí CoverageResult
3. `ADAPTER_FACTORY.create(iface, MOCK)` ‚Üí Adapter
4. `TEST_EXECUTOR.run(tests, MOCK)` ‚Üí TestResult
5. `TEST_REPORTER.format(result)` ‚Üí Report
6. `SCENARIO_DRIVER.run(workflow)` ‚Üí ScenarioResult

---

## [workflow] AUTOMATION_WORKFLOW

**Purpose**: Event-driven automation handling and error recovery.

**Steps**:
1. `WORKFLOW_DISPATCHER.dispatch(trigger)` ‚Üí WorkflowResult
2. [Role] `AUTOMATE_CONTROLLER.orchestrate(steps)` ‚Üí AutomationResult
3. `ERROR_PRINTER.print(errors)` ‚Üí FormattedErrors
4. [Role] `RECOVERY_AGENT.recover(error)` ‚Üí RecoveryResult

---

## [workflow] TRACEABILITY_WORKFLOW

**Purpose**: Verify linkage between all layers and components.

**Steps**:
1. `SCANNER` / `PARSER` (reused)
2. [Role] `TRACEABILITY_GUARDIAN.verify(refs)` ‚Üí TraceResult
3. `STATS_COLLECTOR.collect(specs)` ‚Üí Stats

---

---

## [interface] WORKFLOW_TEST_EXECUTOR

```code
interface WorkflowTestExecutor {
  run(workflow_id: string, env: 'MOCK' | 'REAL'): WorkflowResult
}

interface WorkflowResult {
  passed: boolean
  failed_step?: string
  steps_executed: string[]
}
```

