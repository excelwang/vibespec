# VIBESPEC PROJECT SPECS (v3.2.0)
> üö® INSTRUCTION: You are an Agent reading the Project Bible.
> 1. Always check `L1: Contracts` before writing code.
> 2. `L0: Vision` defines the scope. Do not hallucinate features.
> 3. `L1` overrides `L3` if there is a conflict.

## üó∫Ô∏è INDEX
- [L0-VISION: VISION](#source-l0-vision)
- [L1-CONTRACTS: CONTRACTS](#source-l1-contracts)
- [L2-ARCHITECTURE: ARCHITECTURE](#source-l2-architecture)
- [L3-RUNTIME: RUNTIME](#source-l3-runtime)

---

<a id='source-l0-vision'></a>
# Source: L0-VISION.md
RELIABILITY: Use for Context
---

# L0: Vibespec Vision

> **Core Purpose**: User wants Vibespec to build specs that guide agents to generate user project source code with **maintainability**, **observability**, **determinism**, and **modularity**.

## VISION.SCOPE

User wants vibespec to be a **specification management framework** (not a code generator).

### In-Scope
- **VAL**: User wants vibespec to validate specs hierarchically (L0-L3).
- **TRACE**: User wants vibespec to track layer dependencies for traceability.
- **DOCS**: User wants vibespec to compile specs into a single authoritative document.
- **COV**: User wants vibespec to track test-to-spec coverage via `@verify_spec`.
- **IDEAS**: User wants vibespec to ingest raw ideas and refine them into specs.
- **REFL**: User wants vibespec to reflect on conversations and extract new ideas.
- **DEPS**: User wants vibespec to operate with zero third-party dependencies.
- **AUTO**: User wants vibespec to automate workflows via scripts first.
- **SKILL**: User wants vibespec to distribute as an agentic skill (SKILL.md).

### Out-of-Scope
- **LLM**: User does NOT want vibespec to generate code (delegated to external agents).
- **UI**: User does NOT want vibespec to provide UI design tools.
- **PM**: User does NOT want vibespec to manage projects or tickets.

## VISION.CODE_QUALITY_GOALS

User wants specs generated by Vibespec to guide agents to generate code with:

| Quality | Definition | Verification |
|---------|------------|--------------|
| **MAINTAINABILITY** | Clarity over cleverness. Modular, readable, low coupling. | Code review, static analysis |
| **OBSERVABILITY** | If you can't see it, assume it's broken. Logs, metrics, traces. | Monitoring coverage |
| **DETERMINISM** | Stochastic behavior is a bug unless required. Reproducible results. | Test repeatability |
| **MODULARITY** | High cohesion, low coupling. Single responsibility. | Dependency analysis |

## VISION.AUTOMATION

- **SCRIPT_FIRST**: User wants vibespec to script any formalizable task.
- **COGNITIVE_LOAD**: User wants vibespec to minimize LLM/human cognitive load via deterministic scripts.
- **EVOLUTION**: User wants vibespec to evolve by rigidifying patterns into code.
- **ITEM_CLASSIFICATION**: User wants vibespec to tag L3 items with execution type (PROMPT_NATIVE | SCRIPT | WORKFLOW | PROMPT_FALLBACK).

## VISION.CERTIFICATION

- **COMPLIANCE**: User wants vibespec to validate that agents correctly execute L1 Agent Acceptance and L3 Role Decisions prescribed in `specs/`.
- **PROOF**: User wants vibespec to generate certification artifacts (exams) to prove this compliance.

## VISION.EXTENSIBILITY

- **PROJECT_RULES**: User wants vibespec to allow project-specific validation rules.
- **RULE_LOCATION**: User wants vibespec to define custom rules in L1-CONTRACTS.
- **CORE_VS_CUSTOM**: User wants vibespec to separate universal rules from project-specific ones.
- **SCHEMA_DRIVEN**: User wants vibespec to use declarative schemas for rule definitions.

---

## VISION.TRACEABILITY

- **CHAIN**: User wants vibespec to support full traceability from request to verified code.
- **WORKFLOW**: User wants vibespec to follow: Request ‚Üí Breakdown ‚Üí Specs ‚Üí Implementation ‚Üí Verification.
- **GRANULARITY**: User wants vibespec to make every spec statement atomically addressable.
- **GOAL**: User wants vibespec to ensure every line of code satisfies a requirement.

## VISION.VIBE_CODING

- **TRUTH**: User wants vibespec to treat specs as the primary source of truth.
- **PARADIGM**: User wants vibespec to enable: Human defines Spec ‚Üí AI writes code ‚Üí Human & AI verify.
- **HUMAN_GATE**: User wants vibespec to require human approval before persisting spec changes.
- **AI_ASSIST**: User wants vibespec to leverage AI for generation, validation, and refinement.
- **SHIFT_LEFT**: User wants vibespec to catch errors at spec level, not implementation.

## VISION.PHILOSOPHY

- **HUMAN_CENTRIC**: User wants vibespec to produce atomic, readable specs.
- **LLM_CENTRIC**: User wants vibespec to generate concise, deterministic prompts.
- **SYSTEM_CENTRIC**: User wants vibespec to manage complexity via scripts (see AUTOMATION.SCRIPT_FIRST).
- **SEPARATION**: User wants vibespec to strictly separate assertions from their rationale.

## VISION.AGENT_AS_DEVELOPER

- **PRIMARY_CONSUMER**: User wants vibespec to compile a "Developer's Bible" for AI agents.
- **FULL_CONTEXT**: User wants vibespec to provide AI with "God's Eye View" of internals.
- **INFORMATION_COMPLETENESS**: User wants vibespec to retain all sections for code quality.

## VISION.COMPILATION_STRUCTURE

- **LLM_FRIENDLY**: User wants vibespec to optimize compiled output for agent consumption.
- **CONTEXT_ANCHORS**: User wants vibespec to include HTML anchors for precise retrieval.
- **NAVIGATION**: User wants vibespec to include preamble and TOC.
- **NOISE_REDUCTION**: User wants vibespec to strip frontmatter during compilation.

## VISION.FORMAL_SYNTAX

- **PRECISION_OVER_PROSE**: User wants vibespec to prioritize formal notation over prose.
- **FORMALISMS**: User wants vibespec to use Mermaid, JSON/TypeScript schemas, pseudocode.
- **MULTIPLIER**: User wants vibespec to leverage high-density formal blocks.

## VISION.UBIQUITOUS_LANGUAGE

User wants vibespec to use precise, unambiguous terminology:
| Term | Definition |
|------|------------|
| Validate | Structural/static checks by scripts |
| Verify | Dynamic/runtime checks by tests |
| Assert | Hard blocking condition in code |
| Pipeline | Linear sequence of steps |
| Flow | Branching logic path |
| Violation | Breaking a spec rule |
| Error | Runtime crash or exception |

<a id='source-l1-contracts'></a>
# Source: L1-CONTRACTS.md
RELIABILITY: AUTHORITATIVE
---

# L1: Vibespec Behavior Contracts

> **Subject**: Agent | Script. Pattern: `[Agent|Script] MUST [action]`
> - Responsibility: WHO is accountable
> - Verification: HOW to measure compliance

---

## CONTRACTS.L3_TYPE_ANNOTATION

- **TYPE_REQUIRED**: Script MUST enforce `[Type: X]` annotation on all L3 items.
  > Responsibility: Validation ‚Äî ensure routing to correct execution mechanism.
  > Verification: Zero L3 items without type annotation.
  (Ref: VISION.AUTOMATION.ITEM_CLASSIFICATION)

- **SCRIPT_THRESHOLD**: Agent SHOULD assign `SCRIPT` type if task is deterministic and <100 LOC.
  > Responsibility: Decision quality ‚Äî balance automation vs complexity.
  > Verification: SCRIPT assigned for eligible tasks.
  (Ref: VISION.AUTOMATION.SCRIPT_FIRST)

- **FALLBACK_RATIONALE**: Agent SHOULD document rationale for `PROMPT_FALLBACK` items.
  > Responsibility: Transparency ‚Äî explain automation barriers.
  > Verification: All PROMPT_FALLBACK items have rationale.

- **PROMPT_BATCHING**: Agent SHOULD batch adjacent PROMPT_NATIVE items.
  > Responsibility: Efficiency ‚Äî reduce LLM call overhead.
  > Verification: No unbatched adjacent prompts.
  (Ref: VISION.AUTOMATION.COGNITIVE_LOAD)

- **SCRIPT_NO_LLM**: Script MUST NOT contain LLM API calls.
  > Responsibility: Separation ‚Äî scripts are tools, not thinkers.
  > Verification: Zero LLM terms in SCRIPT items.
  (Ref: VISION.AUTOMATION)

---

## CONTRACTS.LEAF_TYPE_PURITY

- **PURE_LEAF**: Script MUST enforce L2 leaf items are pure Agent OR pure Script type.
  > Responsibility: Separation ‚Äî no mixed responsibilities in leaf nodes.
  > Verification: Zero items with both Agent and Script keywords.
  (Ref: VISION.PHILOSOPHY.SEPARATION)

- **AGENT_KEYWORDS**: Agent indicators: ËØ≠‰πâÂàÜÊûê, ‰∏ä‰∏ãÊñá, Âà§Êñ≠, Êé®ÁêÜ, semantic, context, decide, infer.
- **SCRIPT_KEYWORDS**: Script indicators: ÈÅçÂéÜ, ËÆ°Êï∞, ÊéíÂ∫è, Ëß£Êûê, scan, count, sort, parse, format.

- **DECOMPOSE_MIXED**: Agent MUST decompose mixed items until each leaf is pure.
  > Responsibility: Granularity ‚Äî continue splitting until purity achieved.
  > Verification: All leaf items pass purity check.
  (Ref: VISION.PHILOSOPHY.SEPARATION)

---

## CONTRACTS.IDEAS_PIPELINE

- **BATCH_READ**: Script MUST read all idea files before analysis.
  > Responsibility: Data integrity ‚Äî complete picture for prioritization.
  > Verification: `files_read == files_exist`.
  (Ref: VISION.SCOPE.IDEAS)

- **TIMESTAMP_ORDER**: Script MUST sort ideas by filename timestamp.
  > Responsibility: Preserve user intent sequence.
  > Verification: Processing order matches chronological order.
  (Ref: VISION.SCOPE.IDEAS)

- **LEVEL_SEEKING**: Agent MUST classify each idea to highest applicable layer.
  > Responsibility: Shift-left ‚Äî prevent detail pollution.
  > Verification: Each segment has correct layer assignment.
  (Ref: VISION.VIBE_CODING.SHIFT_LEFT)

- **DECOMPOSITION**: Agent MUST split mixed-level ideas and process sequentially.
  > Responsibility: Architectural integrity ‚Äî serialize changes.
  > Verification: Higher layers approved before lower layers processed.
  (Ref: VISION.PHILOSOPHY.SYSTEM_CENTRIC)

- **APPROVAL_REQUIRED**: Agent MUST pause for human review after creating idea file.
  > Responsibility: Human gate ‚Äî prevent drift from user intent.
  > Verification: `notify_user` called after each idea creation.
  (Ref: VISION.VIBE_CODING.HUMAN_GATE)

- **COMPILE_PROMPT**: Agent SHOULD prompt for compilation when ideas/ is empty.
  > Responsibility: Artifact sync ‚Äî keep compiled output current.
  > Verification: Prompt shown when preconditions met.
  (Ref: VISION.AUTOMATION.EVOLUTION)

- **CONFLICT_DETECT**: Agent MUST identify conflicting ideas before resolution.
  > Responsibility: Analysis ‚Äî detect overlapping or contradictory statements.
  > Verification: Conflict pairs logged before resolution applied.
  (Ref: VISION.SCOPE.IDEAS)



- **CONFLICT_RES**: Agent MUST resolve detected conflicts by latest timestamp.
  > Responsibility: Truth source ‚Äî most recent intent wins.
  > Verification: Later idea values supersede earlier ones.
  (Ref: VISION.SCOPE.IDEAS)

---

## CONTRACTS.REVIEW_PROTOCOL

- **SELF_AUDIT**: Agent MUST read full layer content after revision.
  > Responsibility: Quality ‚Äî catch errors before human review.
  > Verification: Self-check performed on each edit.
  (Ref: VISION.VIBE_CODING.SHIFT_LEFT)

- **QUALITY_ALIGNMENT**: Agent SHOULD verify TARGET_PROJECT pillar alignment.
  > Responsibility: Maintainability, observability, determinism, modularity.
  > Verification: Warning raised for non-alignment.
  (Ref: VISION.TARGET_PROJECT)

- **HIERARCHY_CHECK**: Agent MUST load parent layer before editing child.
  > Responsibility: Traceability ‚Äî prevent drift from parent requirements.
  > Verification: Parent layer loaded on edit start.
  (Ref: VISION.TRACEABILITY.CHAIN)



- **REDUNDANCY**: Agent MUST flag duplicate definitions and overlapping content.
  > Responsibility: Lean specs ‚Äî avoid maintenance burden from duplicated/overlapping items.
  > Verification: Warning on redundant sections or items with overlapping scope.
  (Ref: VISION.PHILOSOPHY.SYSTEM_CENTRIC)

- **CONTRADICTION**: Agent MUST flag conflicts with existing content.
  > Responsibility: Consistency ‚Äî detect axiom breakage.
  > Verification: Error on logical contradiction.
  (Ref: VISION.VIBE_CODING.TRUTH)

- **NOTIFICATION**: Agent MUST present all findings during approval.
  > Responsibility: Transparency ‚Äî enable informed decisions.
  > Verification: All findings shown to user.
  (Ref: VISION.VIBE_CODING.PARADIGM)

- **SEQUENTIAL_ONLY**: Agent MUST NOT edit multiple layers in one turn.
  > Responsibility: Safety ‚Äî prevent cascading failures.
  > Verification: Single layer per turn.
  (Ref: VISION.TRACEABILITY.CHAIN)



- **SKILL_TRACEABILITY**: Agent MUST NOT edit SKILL.md without updating L3.
  > Responsibility: Traceability ‚Äî SKILL.md is derived artifact.
  > Verification: L3 updated before SKILL.md.
  (Ref: VISION.TRACEABILITY.CHAIN)

- **ROLE_FIRST_REVIEW**: Agent MUST evaluate revision quality through REVIEWER role before fixing validation errors.
  > Responsibility: Quality-first ‚Äî assess content quality before mechanical fixes.
  > Verification: REVIEWER role assessment logged before validate.py execution.
  (Ref: VISION.VIBE_CODING.SHIFT_LEFT)

- **LAYER_SPECIFIC**: Agent MUST apply layer-specific review criteria during quality review.
  > Responsibility: Precision ‚Äî each layer has distinct validation focus.
  > Verification: Review checklist matches layer type (L0=Vision, L1=Contracts, L2=Arch, L3=Impl).
  (Ref: VISION.VIBE_CODING.SHIFT_LEFT)

- **CASCADE_REVIEW**: Agent MUST evaluate downstream spec impact when reviewing current level.
  > Responsibility: Coherence ‚Äî identify required updates to child-level specs.
  > Verification: Review output includes proposed reorganization for L(N+1).
  (Ref: VISION.TRACEABILITY.CHAIN)

---

## CONTRACTS.REJECTION_HANDLING

- **AUTOMATED_RETRY**: Agent MAY self-correct up to 3 times for fixable errors.
  > Responsibility: Recovery ‚Äî minimize human intervention for minor issues.
  > Verification: Max 3 retry attempts.
  (Ref: VISION.AUTOMATION.COGNITIVE_LOAD)

- **AUTOMATED_GIVEUP**: Agent MUST revert and halt after 3 failed retries.
  > Responsibility: Safety ‚Äî prevent infinite loops.
  > Verification: Revert triggered on 4th failure.
  (Ref: VISION.AUTOMATION.COGNITIVE_LOAD)

- **HUMAN_REJECTION**: Agent MUST revert to pre-task state on user rejection.
  > Responsibility: Clean slate ‚Äî enable fresh approach.
  > Verification: Full revert on "try different approach".
  (Ref: VISION.VIBE_CODING.PARADIGM)

- **NO_PARTIAL_COMMITS**: Script MUST ensure atomic layer commits.
  > Responsibility: Transactional integrity ‚Äî no broken states.
  > Verification: Layer fully approved or fully reverted.
  (Ref: VISION.VIBE_CODING.TRUTH)

---

## CONTRACTS.REFLECT

- **CONTEXT_BASED**: Agent SHOULD extract ideas from current conversation.
  > Responsibility: Efficiency ‚Äî use existing context.
  > Verification: Ideas extracted without external log access.
  (Ref: VISION.SCOPE.REFL)

- **HUMAN_REVIEW**: Agent MUST get approval before saving distilled ideas.
  > Responsibility: Human gate ‚Äî verify AI insights.
  > Verification: Approval requested before file creation.
  (Ref: VISION.VIBE_CODING.HUMAN_GATE)

---

## CONTRACTS.SCRIPT_FIRST

- **TARGET**: Script MUST handle file I/O, validation, archival, formatting.
  > Responsibility: Reliability ‚Äî 100% deterministic for mechanical ops.
  > Verification: Scripts used for listed operations.
  (Ref: VISION.AUTOMATION.SCRIPT_FIRST)

- **GOAL**: Script SHOULD reduce token consumption vs LLM approach.
  > Responsibility: Efficiency ‚Äî free LLM for reasoning.
  > Verification: Measurable token savings.
  (Ref: VISION.AUTOMATION.COGNITIVE_LOAD)

- **PROACTIVE**: Agent MUST propose scripts for repetitive workflows.
  > Responsibility: Evolution ‚Äî drive increasing autonomy.
  > Verification: Script proposal after 3+ repetitions.
  (Ref: VISION.AUTOMATION.EVOLUTION)

- **DETERMINISM**: Script MUST use deterministic algorithms for mechanical tasks.
  > Responsibility: Predictability ‚Äî randomness is liability.
  > Verification: No stochastic behavior in scripts.
  (Ref: VISION.PHILOSOPHY.LLM_CENTRIC)

- **ZERO_DEPS**: Script MUST use only standard library.
  > Responsibility: Portability ‚Äî no supply chain risk.
  > Verification: No pip dependencies.
  (Ref: VISION.SCOPE.DEPS)

---

## CONTRACTS.SCRIPT_USABILITY

- **HELP_MESSAGE**: Script MUST implement `--help` with usage and arguments.
  > Responsibility: Discoverability ‚Äî reduce cognitive load.
  > Verification: Help output on `--help` flag.
  (Ref: VISION.AUTOMATION.COGNITIVE_LOAD)

- **AGENT_FRIENDLY_OUTPUT**: Script MUST produce output that is actionable, locatable, and structured.
  > Responsibility: Clarity ‚Äî enable agents to parse and act on results.
  > Verification: Output includes file paths, line numbers, IDs, and action recommendations.
  (Ref: VISION.CODE_QUALITY_GOALS.OBSERVABILITY)

---

## CONTRACTS.BOOTSTRAP

- **DETECTION**: Script MUST detect missing `specs/` and trigger bootstrap.
  > Responsibility: Safety ‚Äî prevent operation on uninitialized project.
  > Verification: Bootstrap triggered when specs/ absent.
  (Ref: VISION.SCOPE.IDEAS)

- **SCOPE_INQUIRY**: Agent MUST ask user to describe project.
  > Responsibility: Capture ‚Äî get raw user intent.
  > Verification: Open-ended question asked.
  (Ref: VISION.VIBE_CODING.PARADIGM)

- **SCOPE_REFORM**: Agent MUST convert input to SHALL/SHALL NOT statements.
  > Responsibility: Formalization ‚Äî transform vague to verifiable.
  > Verification: Output contains In-Scope and Out-of-Scope.
  (Ref: VISION.VIBE_CODING.SHIFT_LEFT)

- **APPROVAL_GATE**: Agent MUST get approval before creating files.
  > Responsibility: Human gate ‚Äî prevent misdirected init.
  > Verification: Approval before any file creation.
  (Ref: VISION.VIBE_CODING.HUMAN_GATE)

- **INITIALIZATION**: Script MUST create L0-VISION.md and ideas/ on approval.
  > Responsibility: Structure ‚Äî minimum viable spec foundation.
  > Verification: Required files exist after init.
  (Ref: VISION.SCOPE.VAL)

- **CONFIG_TEMPLATE**: Script MUST auto-generate `vibespec.yaml` using the standard template `assets/templates/vibespec.yaml`.
  > Responsibility: Standardization ‚Äî prevent configuration drift at project inception.
  > Verification: `vibespec.yaml` matches template structure.
  (Ref: VISION.AUTOMATION.EVOLUTION)

---

## CONTRACTS.TRIGGERS

- **TRIGGER_SCAN**: Script MUST scan ideas/ on bare `vibespec` invocation.
  > Responsibility: Default action ‚Äî process pending ideas.
  > Verification: Ideas scanned when no arguments.
  (Ref: VISION.SCOPE.IDEAS)

- **TRIGGER_CAPTURE**: Script MUST save inline content as timestamped idea.
  > Responsibility: Capture ‚Äî save raw thoughts immediately.
  > Verification: File created with timestamp name.
  (Ref: VISION.VIBE_CODING.PARADIGM)

- **TRIGGER_REVIEW**: Script MUST accept `vibespec review [ID]` to audit specific specs.
  > Responsibility: Audit ‚Äî on-demand quality check.
  > Verification: Runs review protocol on target spec.
  (Ref: VISION.VIBE_CODING.SHIFT_LEFT)

- **TRIGGER_BUG**: Script MUST accept `vibespec bug [desc]` to initiate spec-based RCA.
  > Responsibility: Maintenance ‚Äî formalize bug fixing.
  > Verification: RCA steps logged before idea creation.
  (Ref: VISION.VIBE_CODING.SHIFT_LEFT)

- **TRIGGER_ALIASES**: Script MUST recognize: `vibespec`, `vibespec`, `vibe spec`.
  > Responsibility: Usability ‚Äî reduce friction.
  > Verification: All aliases work identically.
  (Ref: VISION.PHILOSOPHY.HUMAN_CENTRIC)

- **IDLE_BEHAVIOR**: Agent MUST enter Validation Mode when ideas/ empty and SKILL.md exists.
  > Responsibility: Self-hosting ‚Äî continuous health monitoring.
  > Verification: Validation Mode triggered on conditions.
  (Ref: VISION.AUTOMATION.EVOLUTION)

- **EMPTY_PROMPT**: Agent MUST invite brainstorming when project empty.
  > Responsibility: Onboarding ‚Äî friendly new project experience.
  > Verification: Invitation shown on empty state.
  (Ref: VISION.PHILOSOPHY.HUMAN_CENTRIC)

---

## CONTRACTS.VALIDATION_MODE



- **FULL_SCAN**: Script MUST run validation across all layers.
  > Responsibility: Completeness ‚Äî scan L0-L3.
  > Verification: All spec files validated.
  (Ref: VISION.SCOPE.VAL)

- **REPORT**: Agent MUST summarize orphans, ratio warnings, terminology issues.
  > Responsibility: Feedback ‚Äî actionable maintenance report.
  > Verification: All findings listed.
  (Ref: VISION.VIBE_CODING.TRUTH)

- **FIX_PROPOSAL**: Agent MUST generate ideas for found errors.
  > Responsibility: Closing loop ‚Äî convert issues to work items.
  > Verification: Idea file created for each issue.
  (Ref: VISION.AUTOMATION.EVOLUTION)

- **COMPILE_PROMPT**: Agent SHOULD prompt for compilation on pass.
  > Responsibility: Artifact sync ‚Äî keep output current.
  > Verification: Prompt shown on clean validation.
  (Ref: VISION.SCOPE.DOCS)

---

## CONTRACTS.CUSTOM_RULES

- **RULE_FILE**: Script MUST load rules from `specs/.vibe-rules.yaml`.
  > Responsibility: Separation ‚Äî project rules separate from framework.
  > Verification: File loaded when present.
  (Ref: VISION.EXTENSIBILITY.RULE_LOCATION)

- **RULE_SCHEMA**: Script MUST validate rule schema: id, layer, type, severity.
  > Responsibility: Correctness ‚Äî reject malformed rules.
  > Verification: Error on missing required fields.
  (Ref: VISION.EXTENSIBILITY.SCHEMA_DRIVEN)



- **VIBE_SPEC_RULES**: This project's custom rules:
  ```yaml
  rules:
    - id: SCRIPT_NO_LLM
      layer: 3
      type: forbidden_terms
      match_header: "[Type: SCRIPT]"
      terms: ["prompt(", "llm.", "openai", "anthropic"]
      severity: warning

    - id: PROMPT_NO_PSEUDOCODE
      layer: 3
      type: forbidden_pattern
      match_header: "PROMPT_NATIVE|PROMPT_FALLBACK"
      pattern: "```pseudocode"
      severity: warning
  ```
  (Ref: VISION.EXTENSIBILITY.PROJECT_RULES)

---

## CONTRACTS.SKILL_DISTRIBUTION

- **SKILL_MD**: Script MUST treat SKILL.md as single source of truth for capabilities.
  > Responsibility: Auditability ‚Äî version-controlled capabilities.
  > Verification: Capabilities match SKILL.md.
  (Ref: VISION.SCOPE.SKILL)

- **COMPLIANCE**: Script MUST validate SKILL.md against skill-creator schema.
  > Responsibility: Ecosystem compatibility.
  > Verification: Schema validation passes.
  (Ref: VISION.SCOPE.SKILL)

- **ENTRY_POINT**: Script MUST use `src/SKILL.md` as skill entry.
  > Responsibility: Location ‚Äî consistent skill path.
  > Verification: Loader finds skill at path.

- **TRIGGER_WORDS**: Script MUST recognize: vibespec, vibespec, vibe spec, refine specs.
  > Responsibility: Activation ‚Äî multiple aliases.
  > Verification: All triggers activate skill.
  (Ref: VISION.PHILOSOPHY.HUMAN_CENTRIC)

---

## CONTRACTS.METADATA

- **FRONTMATTER**: Script MUST validate YAML frontmatter with `version` field.
  > Responsibility: Automation ‚Äî machine-parseable metadata.
  > Verification: Error on missing version.

---



---

## CONTRACTS.TRACEABILITY

- **SEMANTIC_IDS**: Script MUST enforce `- **KEY**: ...` format (no sequential numbering).
  > Responsibility: Addressability ‚Äî unique semantic keys.
  > Verification: Error on numbered lists.

- **IN_PLACE_REFS**: Script MUST require `(Ref: PARENT_ID)` on downstream items.
  > Responsibility: Linkage ‚Äî explicit parent references.
  > Verification: Error on missing refs.

- **DRIFT_DETECTION**: Script MUST reject references to non-existent IDs.
  > Responsibility: Integrity ‚Äî no dangling refs.
  > Verification: Error on invalid ref.

- **COMPLETENESS**: Script MUST ensure each upstream ID has downstream coverage.
  > Responsibility: Coverage ‚Äî no orphan requirements.
  > Verification: Error on 0% coverage.

- **ANCHORING**: Script MUST require at least one parent ref per downstream item.
  > Responsibility: Grounding ‚Äî all items anchored.
  > Verification: Error on unanchored items.

- **L2_L3_IMPLEMENTATION**: Script MUST warn if L2 Component has no L3 interface implementing it.
  > Responsibility: Implementation coverage ‚Äî every Component should have technical specification.
  > Verification: Warning on L2 Component without `Implements: [Component: ...]` in L3.

(Ref: VISION.TRACEABILITY.CHAIN), (Ref: VISION.TRACEABILITY.GOAL)

---

---

## CONTRACTS.QUANTIFIED_VALIDATION

- **ATOMICITY**: Script MUST enforce <50 words per L0 statement.
- **DEPTH**: Script MUST enforce <=2 nesting levels.
- **TERMINOLOGY**: Script MUST validate controlled vocabulary usage.
- **RFC2119**: Script MUST require >=50% RFC2119 keyword density in L1.

(Ref: VISION.PHILOSOPHY.HUMAN_CENTRIC)

---

## CONTRACTS.ALGEBRAIC_VALIDATION

- **MILLERS_LAW**: Script MUST enforce Fan-Out <= 7.
- **CONSERVATION**: Script MUST enforce coverage sum >= 100%.
- **EXPANSION_RATIO**: Script SHOULD warn if L(N)/L(N-1) ratio outside 1.0-10.0.
- **TEST_COVERAGE**: Script SHOULD warn if L3 leaf has no `@verify_spec` reference.

(Ref: VISION.SCOPE.COV)

---

## CONTRACTS.L3_QUALITY

- **FIXTURE_REQUIRED**: L3 interface/algorithm MUST include Fixtures table.
  > Responsibility: Testability ‚Äî every interface needs concrete test cases.
  > Verification: Warning if `Fixtures` table missing.

- **CASE_COVERAGE**: Fixtures SHOULD include Normal, Edge, and Error cases.
  > Responsibility: Robustness ‚Äî test boundaries and failures.
  > Verification: Warning if any case type missing.

- **TYPE_SIGNATURE**: L3 interface MUST include typed function signature (code block).
  > Responsibility: Precision ‚Äî unambiguous contract for implementation.
  > Verification: Warning if no code block present.

- **INTERFACE_COMPATIBILITY**: Script MUST verify type compatibility between interoperating interfaces.
  > Responsibility: Integration ‚Äî ensure producer output matches consumer input.
  > Verification: Error if output type of producer does not match input type of consumer.

(Ref: VISION.FORMAL_SYNTAX.PRECISION_OVER_PROSE)

---

## CONTRACTS.STRICT_TESTABILITY

- **DEFAULT_TESTABLE**: Items with MUST/SHOULD/MAY are testable requirements.
- **RATIONALE_SEPARATION**: Use `> Rationale:` block for explanations.
- **RFC2119_ENFORCEMENT**: Script MUST require RFC2119 keyword in L1 items.
- **MOCK_GENERATION**: Agent MUST generate mock objects for external interfaces.
  > Responsibility: Isolation ‚Äî unit tests must not depend on environment.
  > Verification: Mocks used in generated tests.

- **ENVIRONMENT_TOGGLE**: Script MUST support `TEST_ENV=MOCK|REAL` switch.
  > Responsibility: Flexibility ‚Äî validation (Mock) vs verification (Real).
  > Verification: Tests run against Real implementation when set.

- **MOCK_FIRST**: Agent SHOULD run tests in MOCK mode during development.
  > Responsibility: Early validation ‚Äî verify spec logic before implementation.
  > Verification: MOCK tests pass before REAL tests are attempted.

- **SKIP_UNIMPLEMENTED**: Script MUST report SKIP (not FAIL) for missing implementations in REAL mode.
  > Responsibility: Clarity ‚Äî distinguish "not implemented" from "implemented incorrectly".
  > Verification: REAL mode returns SKIP when adapter not found.

- **RESULT_STATES**: Script MUST support result states: PASS, FAIL, SKIP, ERROR.
  > Responsibility: Granularity ‚Äî enable precise test outcome reporting.
  > Verification: Test report includes all four states.

- **ROLE_ALWAYS_MOCK**: Role output MUST remain mocked regardless of TEST_ENV.
  > Responsibility: Determinism ‚Äî scripts can execute full tests without LLM.
  > Verification: Role adapter returns fixture values in both MOCK and REAL modes.

- **WORKFLOW_INTEROP_COVERAGE**: L3 workflow specs MUST cover interface interoperability.
  > Responsibility: Integration ‚Äî verify communication between components.
  > Verification: Workflow tests exercise cross-interface data flow.

- **FULL_WORKFLOW_REQUIRED**: L3 MUST define `full_workflow` covering all Roles and Components.
  > Responsibility: Completeness ‚Äî end-to-end test for entire system.
  > Verification: `workflow/test_full_workflow.py` invokes all roles and components.

- **L1_WORKFLOW_COVERAGE**: Validator MUST ensure every L1 Script item has at least one L3 workflow reference.
  > Responsibility: Traceability ‚Äî L1 requirements verified through integration tests.
  > Verification: `validate.py` checks L1‚ÜíL3 workflow traceability.

(Ref: VISION.SCOPE.COV)

---

## CONTRACTS.COMPILATION

- **LLM_OPTIMIZED**: Script MUST produce single continuous markdown.

- **NAVIGATION**: Script MUST include TOC and preamble.
- **NOISE_REDUCTION**: Script MUST strip frontmatter.

(Ref: VISION.COMPILATION_STRUCTURE)

---

## CONTRACTS.BUILD_STRATEGY

- **GAP_ANALYSIS_FIRST**: IMPLEMENTER MUST perform gap analysis before implementation.
  > Responsibility: Risk reduction ‚Äî understand current state before changes.
  > Verification: Gap report generated before any code modifications.

- **INCREMENTAL_REFACTOR**: IMPLEMENTER SHOULD prefer incremental changes over full rewrites.
  > Responsibility: Stability ‚Äî minimize disruption to working code.
  > Verification: Changes preserve git history continuity.

- **REWRITE_THRESHOLD**: Agent MUST request human approval if gap exceeds 70%.
  > Responsibility: Human oversight ‚Äî large changes require confirmation.
  > Verification: notify_user called when gap > 70%.

- **GAP_CATEGORIES**: Script MUST classify gaps as MISSING, OUTDATED, or ORPHAN.
  > Responsibility: Clarity ‚Äî different gap types require different actions.
  > Verification: Report includes categorized gap list.

- **SKILL_SYNC**: Script MUST synchronize `src/SKILL.md` with `skills` list in `vibespec.yaml`.
  > Responsibility: Consistency ‚Äî `vibespec.yaml` is single source of truth for active skills.
  > Verification: `src/SKILL.md` reflects configured skills.
  (Ref: VISION.SCOPE.SKILL)

- **AUTHORITATIVE_PROMPT**: Script MUST present `specs/.compiled.md` as non-negotiable Law to Agent.
  > Responsibility: Compliance ‚Äî prevent agent improvisation.
  > Verification: Build script outputs "The file specs/.compiled.md is not a suggestion‚Äîit is the LAW."


(Ref: VISION.VIBE_CODING.HUMAN_GATE), (Ref: VISION.VIBE_CODING.TRUTH)

---

## CONTRACTS.TERMINOLOGY_ENFORCEMENT

```yaml
standard_terms:
  Validate: Static checks (linting, structure)
  Verify: Dynamic checks (runtime tests)
  Pipeline: Linear sequence
  Flow: Branching logic
  Assert: Hard-blocking failure
  Error: Runtime exception
  Violation: Spec non-compliance
```

(Ref: VISION.UBIQUITOUS_LANGUAGE)



## CONTRACTS.TESTING_WORKFLOW

- **COVERAGE_REPORT**: Script MUST report L1 and L3 coverage percentages.
  > Responsibility: Visibility ‚Äî show testability gaps.
  > Verification: Report includes L1% and L3% values.

- **UNCOVERED_LIST**: Script MUST list uncovered spec IDs.
  > Responsibility: Actionability ‚Äî identify missing tests.
  > Verification: Uncovered IDs listed in report.

- **META_TEST_GENERATION**: Compiler Script MUST extract testable fixtures to `tests/specs/` mirroring the L1-L3 hierarchy.
  > Responsibility: Synchronization ‚Äî tests are derived directly from specs.
  > Verification: `tests/specs/{layer}/{item}.py` matches spec structure.
  (Ref: VISION.CERTIFICATION.COMPLIANCE)

- **WORKFLOW_VERIFICATION**: Script MUST verify L3 `[workflow]` items using state transition fixtures.
  > Responsibility: Integration Logic ‚Äî prove sequences work end-to-end.
  > Verification: Tests execute workflow steps and assert final state.
  (Ref: VISION.AUTOMATION.ITEM_CLASSIFICATION)

- **TEST_GENERATION**: Agent MUST generate tests for uncovered L3 fixtures.
  > Responsibility: Completeness ‚Äî close coverage gaps.
  > Verification: Test file created for each uncovered L3 item.

- **HUMAN_APPROVAL_TEST**: Agent MUST request approval before saving generated tests.
  > Responsibility: Quality gate ‚Äî human reviews test design.
  > Verification: notify_user called before file write.

- **EXECUTION_REPORT**: Script MUST report PASS/FAIL counts by test type.
  > Responsibility: Transparency ‚Äî summarize test results.
  > Verification: Report includes SCRIPT and PROMPT results.

- **RESULT_EVALUATION**: Agent SHOULD analyze failures and propose fixes.
  > Responsibility: Actionability ‚Äî convert failures to work items.
  > Verification: Idea generated for failing tests.

- **TEST_GRANULARITY**: Script AND Agent tests MUST be organized at H2 (##) level spec granularity.
  > Responsibility: Maintainability ‚Äî one test per H2 section for easy updates.
  > Naming: `test_{item_id}.*` or `answer_key_{item_id}.md` (extension per project framework).
  > Verification: Each test artifact maps to exactly one `## [...]` spec section.

(Ref: VISION.SCOPE.COV), (Ref: VISION.VIBE_CODING.SHIFT_LEFT)

---

## CONTRACTS.CERTIFICATION

- **ANSWER_KEY_LAYER**: Agent MUST generate `answer_key_l1.md` and `answer_key_l3.md` files.
  > Responsibility: Organization ‚Äî separate tests by layer for maintainability.
  > Verification: `tests/specs/agent/answer_key_l{1,3}.md` files exist and match spec layers.
  (Ref: VISION.CERTIFICATION.COMPLIANCE, CONTRACTS.TESTING_WORKFLOW.TEST_GRANULARITY)

- **VERIFY_SPEC_ANNOTATION**: Agent MUST include `@verify_spec_id("SPEC_ID")` annotation per test item.
  > Responsibility: Traceability ‚Äî enable coverage calculation for both agent and script tests.
  > Verification: All test items contain `@verify_spec_id` with valid spec ID.
  (Ref: VISION.SCOPE.COV, CONTRACTS.TESTING_WORKFLOW.COVERAGE_REPORT)

- **ERROR_PRONE_FOCUS**: Agent MUST design tests targeting error-prone usage patterns.
  > Responsibility: Quality ‚Äî cover realistic failure scenarios users encounter.
  > Verification: Tests include edge cases and common misuse patterns.
  (Ref: VISION.CERTIFICATION.COMPLIANCE)

- **COMBINE_QUESTION_PAPER**: Script MUST combine all answer_key files and strip answers to generate `question_paper.md`.
  > Responsibility: Assessment ‚Äî produce unified exam from individual answer keys.
  > Verification: `tests/specs/agent/question_paper.md` contains all items with blank answers.
  (Ref: VISION.CERTIFICATION.PROOF)

- **REALISTIC_CONTEXT**: Agent MUST use realistic Context/Expectation content matching actual project inputs.
  > Responsibility: Relevance ‚Äî test scenarios must reflect real user/script inputs, not placeholders.
  > Verification: answer_key files contain concrete, project-specific examples.
  (Ref: VISION.CERTIFICATION.COMPLIANCE)

- **CONTEXTUAL_SCENARIO**: Vibespec MUST analyze project context to generate and execute a relevant End-to-End Scenario.
  > Responsibility: Relevance ‚Äî prove toolchain works on *this* project.
  > Verification: Generated scenario matches project domain (e.g., User vs. Order).
  (Ref: VISION.TRACEABILITY.CHAIN)
---

## CONTRACTS.MAINTENANCE

- **BUG_RCA**: On `vibespec bug`, Agent MUST trace failures recursively from L3 to L0 to find the root cause spec item.
  > Responsibility: Depth ‚Äî find the true origin.
  > Verification: RCA trace log shows upward traversal.
  (Ref: VISION.VIBE_CODING.SHIFT_LEFT)

- **RECURSIVE_FIX**: Agent MUST verify proposed spec fixes against parent layers (Upward) before cascading changes (Downward).
  > Responsibility: Integrity ‚Äî prevent local fixes from breaking global contracts.
  > Verification: Fix proposal includes parent compliance check.
  (Ref: VISION.TRACEABILITY.CHAIN)

- **DELETION_JUSTIFICATION**: Agent MUST document the reason for any L1-L3 item deletion and request review.
  > Responsibility: Safety ‚Äî prevent accidental regression or scope creep (deletion is scope change).
  > Verification: User approval prompt contains "Motivation: [reason]" for deleted items.
  (Ref: VISION.TRACEABILITY.CHAIN)
---

## CONTRACTS.RELOAD

- **RELOAD_TRIGGER**: When user inputs `vibespec reload`, Agent MUST re-read SKILL.md.
  > Responsibility: Hot-reload ‚Äî apply skill changes without restarting session.
  > Verification: Agent confirms SKILL.md re-loaded after trigger.
  (Ref: VISION.AUTOMATION.EVOLUTION)

---

## CONTRACTS.TEMPLATE_GENERATION

- **USE_TEMPLATES**: Agent MUST use templates from `src/assets/specs/` when generating files.
  > Responsibility: Consistency ‚Äî ensure uniform formatting across all generated specs.
  > Verification: Generated files match template structure.
  (Ref: VISION.PHILOSOPHY.MAINTAINABILITY)

- **TEMPLATE_FILES**: Templates MUST include: IDEA_TEMPLATE.md, L0-VISION.md, L1-CONTRACTS.md, L2-ARCHITECTURE.md, L3-IMPLEMENTATION.md.
  > Responsibility: Completeness ‚Äî provide templates for all spec types.
  > Verification: All template files exist in `src/assets/specs/`.
  (Ref: VISION.TRACEABILITY.CHAIN)

---

## CONTRACTS.STARTUP_MENU

- **INTERACTIVE_START**: When user runs `vibespec` (no args), Agent MUST display capabilities menu and wait for input.
  > Responsibility: Control ‚Äî prevent accidental execution of pending workloads.
  > Verification: Agent outputs usage help and stops execution.
  (Ref: VISION.PHILOSOPHY.HUMAN_CENTRIC)

- **FIRST_RUN_COMPREHENSION**: On first `vibespec` invocation, Agent MUST read all L0-L3 specs before executing.
  > Responsibility: Context ‚Äî ensure deep project understanding before action.
  > Verification: Agent summarizes project understanding before proceeding.
  (Ref: VISION.AGENT_AS_DEVELOPER.FULL_CONTEXT)

---


## CONTRACTS.AUTOMATE_MODE

- **AUTOMATE_TRIGGER**: When user inputs `vibespec automate`, Agent MUST enter automate mode.
  > Responsibility: Efficiency ‚Äî enable hands-off batch processing.
  > Verification: Agent processes all ideas without human approval gates.
  (Ref: VISION.AUTOMATION.COGNITIVE_LOAD)

- **AUTO_ACCEPT**: In automate mode, Agent MUST auto-accept own suggestions.
  > Responsibility: Speed ‚Äî skip approval delays for routine changes.
  > Verification: No notify_user calls with BlockedOnUser=true.
  (Ref: VISION.AUTOMATION.SCRIPT_FIRST)

- **AUTO_FIX_WARNINGS**: In automate mode, Agent MUST auto-fix validation warnings.
  > Responsibility: Completeness ‚Äî resolve all cascade warnings automatically.
  > Verification: Validation passes with 0 warnings after automate completes.
  (Ref: VISION.VIBE_CODING.SHIFT_LEFT)

- **BUILD_BEFORE_TEST**: In automate mode, Agent MUST execute Build phase before Test phase.
  > Responsibility: Validity ‚Äî tests must run against latest artifacts.
  > Verification: Workflow sequence is Refine ‚Üí Validate ‚Üí Compile ‚Üí Build ‚Üí Test.
  (Ref: VISION.VIBE_CODING.TRUTH)

<a id='source-l2-architecture'></a>
# Source: L2-ARCHITECTURE.md
RELIABILITY: AUTHORITATIVE
---

# L2: Vibespec Architecture

> **Subject**: Role (Active) | Component (Passive)
> - Role: Observes / Decides / Acts (Agent-driven)
> - Component: Input / Output (Script-driven)
> - Heading levels indicate hierarchy: H2 = Top, H3 = Subsystem, H4 = Leaf

---

## ROLES

> Active entities: observe, decide, act

### ROLES.SPEC_MANAGEMENT

> Specification lifecycle management

#### ARCHITECT

**Role**: Plans spec changes

- **Observes**: Sorted ideas, current spec state, layer definitions
- **Decides**: Target layer, decomposition strategy, conflict resolution
- **Acts**: Creates change proposals, requests approval

(Ref: CONTRACTS.IDEAS_PIPELINE.LEVEL_SEEKING), (Ref: CONTRACTS.IDEAS_PIPELINE.DECOMPOSITION), (Ref: CONTRACTS.IDEAS_PIPELINE.CONFLICT_DETECT)

#### REVIEWER

**Role**: Audits change quality

- **Observes**: Change proposals, parent layer, existing content
- **Decides**: Internal consistency, traceability coverage, contradiction detection
- **Acts**: Approves or rejects, presents to user

(Ref: CONTRACTS.TRIGGERS.TRIGGER_REVIEW), (Ref: CONTRACTS.REVIEW_PROTOCOL.HIERARCHY_CHECK), (Ref: CONTRACTS.REVIEW_PROTOCOL.LAYER_SPECIFIC)
 
 #### QUALITY_AUDITOR
 
 **Role**: Deep quality inspection with role-first assessment
 
 - Observes: Spec content, alignment rules
 - Decides: Compliance with pillars, quality before validation
 - Acts: Flags non-compliance, assesses via role evaluation FIRST

 (Ref: CONTRACTS.REVIEW_PROTOCOL.QUALITY_ALIGNMENT), (Ref: CONTRACTS.REVIEW_PROTOCOL.SELF_AUDIT), (Ref: CONTRACTS.REVIEW_PROTOCOL.ROLE_FIRST_REVIEW)
 
 #### CONSISTENCY_CHECKER
 
 **Role**: Logical consistency and cascade check
 
 - Observes: Parent/Child Specs
 - Decides: Omissions, redundancies, downstream impact
 - Acts: Blocks invalid edits, evaluates cascade impact

 (Ref: CONTRACTS.REVIEW_PROTOCOL.REDUNDANCY), (Ref: CONTRACTS.REVIEW_PROTOCOL.CONTRADICTION), (Ref: CONTRACTS.REVIEW_PROTOCOL.CASCADE_REVIEW)

 #### PROCESS_ENFORCER
 
 **Role**: Enforces workflow constraints
 
 - Observes: Action sequence, approval states
 - Decides: Whether action violates process rules
 - Acts: Blocks multi-layer edits, enforces human review gates

 (Ref: CONTRACTS.REVIEW_PROTOCOL.SEQUENTIAL_ONLY), (Ref: CONTRACTS.REFLECT.HUMAN_REVIEW), (Ref: CONTRACTS.MAINTENANCE.DELETION_JUSTIFICATION)

#### TRACEABILITY_GUARDIAN

**Role**: Ensures traceability chain integrity

- **Observes**: All references, parent-child relationships, coverage metrics
- **Decides**: Orphan detection, dangling refs, staleness detection
- **Acts**: Flags violations, generates fix ideas

(Ref: CONTRACTS.TRACEABILITY.COMPLETENESS), (Ref: CONTRACTS.TRACEABILITY.DRIFT_DETECTION), (Ref: CONTRACTS.VALIDATION_MODE.FIX_PROPOSAL)

### ROLES.USER_INTERACTION

> User interaction roles

#### USER_LIAISON

**Role**: Communicates with human

- **Observes**: Pending approvals, findings, proposals
- **Decides**: Information format, urgency level
- **Acts**: Calls notify_user, waits for response

(Ref: CONTRACTS.REVIEW_PROTOCOL.NOTIFICATION), (Ref: CONTRACTS.IDEAS_PIPELINE.APPROVAL_REQUIRED), (Ref: CONTRACTS.STARTUP_MENU.INTERACTIVE_START)

#### BOOTSTRAP_AGENT

**Role**: Initializes new projects

- **Observes**: Filesystem state, user input
- **Decides**: Whether bootstrap needed, scope formulation
- **Acts**: Prompts for scope, converts to SHALL/SHALL_NOT, creates L0

(Ref: CONTRACTS.BOOTSTRAP.DETECTION), (Ref: CONTRACTS.BOOTSTRAP.SCOPE_REFORM), (Ref: CONTRACTS.BOOTSTRAP.APPROVAL_GATE)
 
 #### ONBOARDING_ASSISTANT
 
 **Role**: Guides new users
 
 - Observes: Empty project state
 - Decides: Engagement strategy
 - Acts: Invites brainstorming
 
 (Ref: CONTRACTS.TRIGGERS.EMPTY_PROMPT), (Ref: CONTRACTS.BOOTSTRAP.SCOPE_INQUIRY), (Ref: CONTRACTS.STARTUP_MENU.FIRST_RUN_COMPREHENSION)

### ROLES.AUTOMATION

> Automation enhancement roles

#### RECOVERY_AGENT

**Role**: Handles failures and rejections

- **Observes**: Error count, rejection signals, system state
- **Decides**: Retry vs revert, whether to change approach
- **Acts**: Attempts fix (max 3), reverts on failure

(Ref: CONTRACTS.REJECTION_HANDLING.AUTOMATED_RETRY), (Ref: CONTRACTS.REJECTION_HANDLING.HUMAN_REJECTION), (Ref: CONTRACTS.AUTOMATE_MODE.AUTO_FIX_WARNINGS)

#### INSIGHT_MINER

**Role**: Extracts specs from conversation

- **Observes**: Current conversation context
- **Decides**: Key decisions, architectural shifts, new requirements
- **Acts**: Creates idea files, requests approval

(Ref: CONTRACTS.REFLECT.CONTEXT_BASED), (Ref: CONTRACTS.MAINTENANCE.BUG_RCA), (Ref: CONTRACTS.MAINTENANCE.RECURSIVE_FIX)

#### PATTERN_SCOUT

**Role**: Identifies automation opportunities

- **Observes**: Agent action history, repetitive patterns
- **Decides**: Script-worthiness (frequency, determinism)
- **Acts**: Proposes new scripts via idea pipeline

(Ref: CONTRACTS.SCRIPT_FIRST.PROACTIVE), (Ref: CONTRACTS.SCRIPT_FIRST.GOAL), (Ref: CONTRACTS.REJECTION_HANDLING.AUTOMATED_GIVEUP)

#### RELOAD_HANDLER

**Role**: Reloads skill definitions

- **Observes**: User `vibespec reload` command
- **Decides**: Whether SKILL.md changed
- **Acts**: Re-reads SKILL.md, confirms reload to user

(Ref: CONTRACTS.RELOAD.RELOAD_TRIGGER)

#### AUTOMATE_CONTROLLER

**Role**: Controls automate mode execution

- **Observes**: User `vibespec automate` command, pending ideas, validation warnings
- **Decides**: Processing order, warning fix strategy
- **Acts**: Processes ideas, auto-accepts suggestions, auto-fixes warnings

(Ref: CONTRACTS.AUTOMATE_MODE.AUTOMATE_TRIGGER), (Ref: CONTRACTS.AUTOMATE_MODE.AUTO_ACCEPT), (Ref: CONTRACTS.AUTOMATE_MODE.BUILD_BEFORE_TEST)

#### TEST_VERIFIER

**Role**: LLM-driven test execution

- **Observes**: L3 prompt items, test fixtures
- **Decides**: Pass/Fail based on behavior, Mocking strategy
- **Acts**: Generates mock-based test code, reports result with evidence

(Ref: CONTRACTS.STRICT_TESTABILITY.MOCK_GENERATION), (Ref: CONTRACTS.TESTING_WORKFLOW.WORKFLOW_VERIFICATION), (Ref: CONTRACTS.STRICT_TESTABILITY.MOCK_FIRST)

#### TEST_DESIGNER

**Role**: Generates test cases from specs

- **Observes**: L3 fixtures, edge cases, error cases, existing test coverage
- **Decides**: Test strategy, boundary scenarios, missing coverage areas
- **Acts**: Generates test code with `@verify_spec` decorators, requests approval

> Rationale: Script implementation would be prohibitively complex due to semantic understanding requirements.

(Ref: CONTRACTS.TESTING_WORKFLOW.TEST_GENERATION), (Ref: CONTRACTS.TESTING_WORKFLOW.HUMAN_APPROVAL_TEST), (Ref: CONTRACTS.LEAF_TYPE_PURITY.DECOMPOSE_MIXED)

#### IMPLEMENTER

**Role**: Synchronizes project artifacts with specs

- **Observes**: `vibespec-full.md`, `vibespec.yaml`, existing source code in `src/`
- **Decides**: Gap analysis (MISSING/OUTDATED/ORPHAN), refactor vs rewrite strategy
- **Acts**: Generates gap report, applies incremental changes, requests approval for large rewrites

(Ref: CONTRACTS.BUILD_STRATEGY.GAP_ANALYSIS_FIRST), (Ref: CONTRACTS.BUILD_STRATEGY.INCREMENTAL_REFACTOR), (Ref: CONTRACTS.REVIEW_PROTOCOL.SKILL_TRACEABILITY)

---

## COMPONENTS

> Passive entities: receive input, produce output

### COMPONENTS.COMPILER_PIPELINE

> Multi-stage compilation pipeline

#### SCANNER

**Component**: Finds spec files

- Input: `path: string`
- Output: `File[]`

(Ref: CONTRACTS.METADATA.FRONTMATTER)

#### PARSER

**Component**: Extracts frontmatter and body

- Input: `file: File`
- Output: `{metadata, body}`

(Ref: CONTRACTS.METADATA.FRONTMATTER), (Ref: CONTRACTS.TRACEABILITY.SEMANTIC_IDS), (Ref: CONTRACTS.L3_TYPE_ANNOTATION.TYPE_REQUIRED)
 
 #### SECTION_PARSER
 
 **Component**: Identifying sections
 
 - Input: `lines: string[]`
 - Output: `Section[]`
 
 (Ref: CONTRACTS.SECTION_MARKERS.H2_ANNOTATION), (Ref: CONTRACTS.SECTION_MARKERS.SYSTEM_SEMANTICS), (Ref: CONTRACTS.SECTION_MARKERS.STANDARD_SEMANTICS)

#### VALIDATOR

**Component**: Executes all validation rules

- Input: `specs: ParsedSpec[]`
- Output: `ValidationResult`

(Ref: CONTRACTS.VALIDATION_MODE.FULL_SCAN), (Ref: CONTRACTS.TRACEABILITY.IN_PLACE_REFS), (Ref: CONTRACTS.TRACEABILITY.ANCHORING)

#### ASSEMBLER

**Component**: Merges specs into document

- Input: `specs: ParsedSpec[]`
- Output: `Document`

(Ref: CONTRACTS.COMPILATION.LLM_OPTIMIZED), (Ref: CONTRACTS.COMPILATION.NOISE_REDUCTION), (Ref: CONTRACTS.COMPILATION.NAVIGATION)

### COMPONENTS.VALIDATOR_CORE

> Rule-based validation engine

#### RULE_ENGINE

**Component**: Executes validation rules

- Input: `rules: Rule[], specs: Spec[]`
- Output: `Violation[]`

(Ref: CONTRACTS.QUANTIFIED_VALIDATION.ATOMICITY), (Ref: CONTRACTS.QUANTIFIED_VALIDATION.DEPTH), (Ref: CONTRACTS.QUANTIFIED_VALIDATION.RFC2119)

#### CUSTOM_RULES_LOADER

**Component**: Loads project custom rules

- Input: `specs_dir: Path`
- Output: `Rule[]`

(Ref: CONTRACTS.CUSTOM_RULES.RULE_FILE), (Ref: CONTRACTS.CUSTOM_RULES.RULE_SCHEMA), (Ref: CONTRACTS.CUSTOM_RULES.VIBE_SPEC_RULES)

#### RESPONSIVENESS_CHECKER

**Component**: Validates coverage

- Input: `graph: SpecGraph`
- Output: `CoverageResult`

(Ref: CONTRACTS.TRACEABILITY.COMPLETENESS), (Ref: CONTRACTS.ALGEBRAIC_VALIDATION.CONSERVATION), (Ref: CONTRACTS.ALGEBRAIC_VALIDATION.MILLERS_LAW)

### COMPONENTS.IDEAS_PROCESSOR

> Ideas processing pipeline

#### BATCH_READER

**Component**: Reads all idea files

- Input: `path: string`
- Output: `Idea[]`

(Ref: CONTRACTS.IDEAS_PIPELINE.BATCH_READ)

#### SORTER

**Component**: Sorts by timestamp

- Input: `ideas: Idea[]`
- Output: `Idea[]` (sorted)

(Ref: CONTRACTS.IDEAS_PIPELINE.TIMESTAMP_ORDER), (Ref: CONTRACTS.IDEAS_PIPELINE.CONFLICT_RES)

#### ARCHIVER

**Component**: Moves processed ideas to archive

- Input: `ideas: Idea[]`
- Output: `void`

(Ref: CONTRACTS.IDEAS_PIPELINE.COMPILE_PROMPT), (Ref: CONTRACTS.VALIDATION_MODE.COMPILE_PROMPT)

### COMPONENTS.SCRIPTS

> Standalone automation tools
 
 #### SKILL_LOADER
 
 **Component**: Loads SKILL.md
 
 - Input: `path`
 - Output: `SkillDef`
 
 (Ref: CONTRACTS.SKILL_DISTRIBUTION.SKILL_MD), (Ref: CONTRACTS.SKILL_DISTRIBUTION.COMPLIANCE), (Ref: CONTRACTS.SKILL_DISTRIBUTION.TRIGGER_WORDS)


#### VALIDATE_SCRIPT

**Script**: `scripts/validate.py`

- Input: `specs_path`
- Output: `ValidationResult`

(Ref: CONTRACTS.SCRIPT_FIRST.TARGET), (Ref: CONTRACTS.SCRIPT_FIRST.ZERO_DEPS), (Ref: CONTRACTS.SCRIPT_USABILITY.AGENT_FRIENDLY_OUTPUT)

#### COMPILE_SCRIPT

**Script**: `scripts/compile.py`

- Input: `specs_path, output_path`
- Output: `Document`

(Ref: CONTRACTS.SCRIPT_FIRST.TARGET), (Ref: CONTRACTS.SCRIPT_USABILITY.HELP_MESSAGE), (Ref: CONTRACTS.TESTING_WORKFLOW.META_TEST_GENERATION)
 
 #### INIT_SCRIPT
 
 **Script**: `scripts/init.py`
 
 - Input: `scope`
 - Output: `L0-VISION.md`, `vibespec.yaml`
 
 (Ref: CONTRACTS.BOOTSTRAP.INITIALIZATION), (Ref: CONTRACTS.BOOTSTRAP.CONFIG_GENERATION)

#### BUILD_SCRIPT

**Script**: `scripts/build.py`

- Input: `vibespec.yaml`
- Output: `BuildReport`, `Prompt`

(Ref: CONTRACTS.BUILD_STRATEGY.AUTHORITATIVE_PROMPT), (Ref: CONTRACTS.BUILD_STRATEGY.GAP_CATEGORIES), (Ref: CONTRACTS.SCRIPT_USABILITY.HELP_MESSAGE)

### COMPONENTS.TRIGGER_ROUTER

> Trigger routing system

#### COMMAND_ROUTER

**Component**: Parses invocation command

- Input: `input: string`
- Output: `{command, args}`

(Ref: CONTRACTS.TRIGGERS.TRIGGER_ALIASES), (Ref: CONTRACTS.TRIGGERS.TRIGGER_CAPTURE), (Ref: CONTRACTS.TRIGGERS.TRIGGER_BUG)

#### WORKFLOW_DISPATCHER

**Role**: Selects handler

- Input: `parsed: ParsedCommand, fs_state: FSState`
- Output: `Handler`
- Logic:
  1. Args ‚Üí Capture workflow
  2. Ideas exist ‚Üí Ideas workflow
  3. SKILL.md exists ‚Üí Validation workflow
  4. Otherwise ‚Üí Bootstrap workflow

(Ref: CONTRACTS.TRIGGERS.TRIGGER_SCAN), (Ref: CONTRACTS.TRIGGERS.IDLE_BEHAVIOR), (Ref: CONTRACTS.SKILL_DISTRIBUTION.ENTRY_POINT)

### COMPONENTS.REPORTING

> Report generation

#### ERROR_PRINTER

**Component**: Formats errors

- Input: `errors: Error[]`
- Output: `string`

(Ref: CONTRACTS.VALIDATION_MODE.REPORT)

#### SUMMARY_GENERATOR

**Component**: Generates summary

- Input: `result: ValidationResult`
- Output: `Summary`

(Ref: CONTRACTS.REVIEW_PROTOCOL.NOTIFICATION)

#### DIFF_VIEWER

**Component**: Shows differences

- Input: `before: Spec, after: Spec`
- Output: `string`

(Ref: CONTRACTS.IDEAS_PIPELINE.APPROVAL_REQUIRED)

### COMPONENTS.QUALITY

> Quality assurance

#### TERM_CHECKER

**Component**: Validates terminology

- Input: `content: string`
- Output: `VocabResult`

(Ref: CONTRACTS.TERMINOLOGY_ENFORCEMENT), (Ref: CONTRACTS.QUANTIFIED_VALIDATION.TERMINOLOGY)

#### ASSERTION_CHECKER

**Component**: Scans for RFC2119 keywords

- Input: `spec: Spec`
- Output: `AssertionResult`

(Ref: CONTRACTS.STRICT_TESTABILITY.RFC2119_ENFORCEMENT), (Ref: CONTRACTS.STRICT_TESTABILITY.DEFAULT_TESTABLE)
 
 #### LINT_CHECKER
 
 **Component**: Checks annotation rules
 
 - Input: `spec: Spec`
 - Output: `LintResult`
 
 (Ref: CONTRACTS.L3_TYPE_ANNOTATION.SCRIPT_THRESHOLD), (Ref: CONTRACTS.L3_TYPE_ANNOTATION.FALLBACK_RATIONALE), (Ref: CONTRACTS.L3_TYPE_ANNOTATION.PROMPT_BATCHING)
 
 #### PURITY_CHECKER
 
 **Component**: Enforces type purity
 
 - Input: `spec: Spec`
 - Output: `PurityResult`
 
 (Ref: CONTRACTS.LEAF_TYPE_PURITY.PURE_LEAF), (Ref: CONTRACTS.LEAF_TYPE_PURITY.AGENT_KEYWORDS), (Ref: CONTRACTS.LEAF_TYPE_PURITY.SCRIPT_KEYWORDS)
 
 #### SCRIPT_SCANNER
 
 **Component**: Scans scripts for safety
 
 - Input: `script: Script`
 - Output: `SafetyResult`
 
 (Ref: CONTRACTS.L3_TYPE_ANNOTATION.SCRIPT_NO_LLM), (Ref: CONTRACTS.SCRIPT_FIRST.DETERMINISM)
 
 #### NOTATION_CHECKER
 
 **Component**: Enforces formal syntax
 
 - Input: `spec: Spec`
 - Output: `NotationResult`
 
 (Ref: CONTRACTS.STRICT_TESTABILITY.RATIONALE_SEPARATION)

### COMPONENTS.INFRASTRUCTURE
 
 > Low-level system operations
 
 #### ATOMIC_WRITER
 
 **Component**: Safe file operations
 
 - Input: `path, content`
 - Output: `void`
 
 (Ref: CONTRACTS.REJECTION_HANDLING.NO_PARTIAL_COMMITS)

> Metrics collection

#### STATS_COLLECTOR

**Component**: Aggregates all metrics

- Input: `specs: Spec[]`
- Output: `{itemCounts, ratios, fanout, wordCounts}`

(Ref: CONTRACTS.ALGEBRAIC_VALIDATION.EXPANSION_RATIO)

#### COVERAGE_ANALYZER

**Component**: Collects testable specs and computes coverage

- Input: `specs_dir: Path, tests_dir: Path`
- Output: `CoverageReport{l1_coverage, l3_coverage, uncovered_ids[]}`
- Logic:
  1. Extract L1 assertions (MUST/SHOULD/MAY) from specs
  2. Extract L3 fixtures from `[interface]`/`[decision]`/`[algorithm]`
  3. Scan tests for `@verify_spec("ID")` or YAML `id:` matches
  4. Compute coverage percentages

(Ref: CONTRACTS.TESTING_WORKFLOW.COVERAGE_REPORT), (Ref: CONTRACTS.TESTING_WORKFLOW.UNCOVERED_LIST), (Ref: CONTRACTS.TESTING_WORKFLOW.TEST_GRANULARITY)

#### TEST_EXECUTOR

**Component**: Runs test suites

- Input: `tests_dir: Path, env: MOCK|REAL`
- Output: `ExecutionResult{passed, failed, skipped}`

(Ref: CONTRACTS.TESTING_WORKFLOW.EXECUTION_REPORT), (Ref: CONTRACTS.STRICT_TESTABILITY.ENVIRONMENT_TOGGLE), (Ref: CONTRACTS.ALGEBRAIC_VALIDATION.TEST_COVERAGE)

#### TEST_REPORTER

**Component**: Formats test results

- Input: `coverage: CoverageReport, execution: ExecutionResult`
- Output: `string` (formatted report)

(Ref: CONTRACTS.TESTING_WORKFLOW.EXECUTION_REPORT), (Ref: CONTRACTS.TESTING_WORKFLOW.RESULT_EVALUATION)

#### ADAPTER_FACTORY

**Component**: Creates MOCK or REAL adapters for test execution

- Input: `interface_id: string, env: MOCK|REAL`
- Output: `Adapter`
- Logic:
  1. If env == MOCK ‚Üí Return MockAdapter (uses L3 Fixtures)
  2. If env == REAL ‚Üí Return RealAdapter (imports user implementation)
  3. If REAL adapter not found ‚Üí Return SkipAdapter

(Ref: CONTRACTS.STRICT_TESTABILITY.ENVIRONMENT_TOGGLE), (Ref: CONTRACTS.STRICT_TESTABILITY.MOCK_GENERATION), (Ref: CONTRACTS.STRICT_TESTABILITY.SKIP_UNIMPLEMENTED)

#### WORKFLOW_TEST_EXECUTOR

**Component**: Executes workflow (integration) tests

- Input: `workflow_id: string, env: MOCK|REAL`
- Output: `WorkflowResult{passed, failed, steps_executed[]}`
- Logic:
  1. Load workflow definition from L3
  2. Execute each step sequentially
  3. Role steps use mocked output (ROLE_ALWAYS_MOCK)
  4. Component steps use env-based adapter

(Ref: CONTRACTS.STRICT_TESTABILITY.WORKFLOW_INTEROP_COVERAGE), (Ref: CONTRACTS.STRICT_TESTABILITY.FULL_WORKFLOW_REQUIRED), (Ref: CONTRACTS.STRICT_TESTABILITY.ROLE_ALWAYS_MOCK)


#### BUILDER

**Component**: Orchestrates spec-to-implementation transformation

- Input: `compiled_spec: Path, skills: string[]`
- Output: `UpdateStatus`

(Ref: VISION.VIBE_CODING.TRUTH), (Ref: VISION.AGENT_AS_DEVELOPER.PRIMARY_CONSUMER), (Ref: CONTRACTS.BUILD_STRATEGY.GAP_CATEGORIES)

#### CERTIFICATION_ENGINE

**Component**: Produces certification artifacts

- Input: `specs: Spec[]`
- Output: `answer_key_l1.md, answer_key_l3.md, question_paper.md`
- Standards:
  - Each item in answer_key files MUST include `@verify_spec_id("SPEC_ID")`
  - Tests MUST focus on error-prone usage patterns

(Ref: CONTRACTS.CERTIFICATION.ANSWER_KEY_GRANULAR), (Ref: CONTRACTS.CERTIFICATION.COMBINE_QUESTION_PAPER), (Ref: CONTRACTS.CERTIFICATION.REALISTIC_CONTEXT)

#### TEMPLATE_LOADER

**Component**: Loads spec templates

- Input: `template_dir: Path`
- Output: `templates: Map<LayerType, Template>`

(Ref: CONTRACTS.TEMPLATE_GENERATION.USE_TEMPLATES), (Ref: CONTRACTS.TEMPLATE_GENERATION.TEMPLATE_FILES)

#### SCENARIO_DRIVER

**Component**: Executes end-to-end scenarios

- Input: `scenario_path: Path`
- Output: `Pass | Fail`

(Ref: CONTRACTS.CERTIFICATION.CONTEXTUAL_SCENARIO), (Ref: CONTRACTS.BUILD_STRATEGY.REWRITE_THRESHOLD)

<a id='source-l3-runtime'></a>
# Source: L3-RUNTIME.md
RELIABILITY: AUTHORITATIVE
---

# L3: Vibespec Runtime

> **Purpose**: Capture complex/error-prone implementation details for testability
> 
> **Content Types**: `[interface]` | `[decision]` | `[algorithm]` | `[workflow]`

---

## [interface] SCANNER

> Implements: [Component: COMPONENTS.COMPILER_PIPELINE.SCANNER]

```typescript
interface Scanner {
  scan(path: string): File[]
}
```

**Fixtures**:
| Input | Expected | Case |
|-------|----------|------|
| "specs/" | File[] | Normal |
| "" | PathError | Error |
| "nonexistent/" | [] | Edge |

**Consumers**: [ARCHITECT]

(Ref: CONTRACTS.L3_QUALITY.FIXTURE_REQUIRED), (Ref: CONTRACTS.L3_QUALITY.CASE_COVERAGE), (Ref: CONTRACTS.L3_QUALITY.TYPE_SIGNATURE), (Ref: CONTRACTS.L3_QUALITY.INTERFACE_COMPATIBILITY)

---

## [interface] PARSER

> Implements: [Component: COMPONENTS.COMPILER_PIPELINE.PARSER]

```typescript
interface Parser {
  parse(file: File): {metadata: Frontmatter, body: string}
}
```

**Fixtures**:
| Input | Expected | Case |
|-------|----------|------|
| Valid spec | {metadata, body} | Normal |
| No frontmatter | {metadata: {}, body} | Edge |
| Binary file | ParseError | Error |

**Consumers**: [ARCHITECT, VALIDATOR]

---

## [interface] VALIDATOR

> Implements: [Component: COMPONENTS.COMPILER_PIPELINE.VALIDATOR]

```typescript
interface Validator {
  validate(specs: ParsedSpec[]): ValidationResult
}

interface ValidationResult {
  errors: Violation[]
  warnings: Violation[]
}
```

**Fixtures**:
| Input | Expected | Case |
|-------|----------|------|
| Valid specs | {errors: [], warnings: []} | Normal |
| Dangling ref | {errors: [DanglingRef]} | Error |
| Orphan item | {warnings: [Orphan]} | Edge |

**Consumers**: [REVIEWER, TRACEABILITY_GUARDIAN]

---

## [interface] ASSEMBLER

> Implements: [Component: COMPONENTS.COMPILER_PIPELINE.ASSEMBLER]

```typescript
interface Assembler {
  assemble(specs: ParsedSpec[]): Document
}
```

**Fixtures**:
| Input | Expected | Case |
|-------|----------|------|
| [L0, L1, L2, L3] | Merged Document | Normal |
| [] | EmptyDoc | Edge |
| Circular deps | AssemblyError | Error |

**Consumers**: [compile.py]

---

## [interface] RULE_ENGINE

> Implements: [Component: COMPONENTS.VALIDATOR_CORE.RULE_ENGINE]

```typescript
interface RuleEngine {
  execute(rules: Rule[], specs: Spec[]): Violation[]
}
```

**Fixtures**:
| Input | Expected | Case |
|-------|----------|------|
| Valid rules + specs | [] | Normal |
| Invalid rule | RuleError | Error |
| Partial match | [Violation] | Edge |

---

## [interface] RESPONSIVENESS_CHECKER

> Implements: [Component: COMPONENTS.VALIDATOR_CORE.RESPONSIVENESS_CHECKER]

```typescript
interface ResponsivenessChecker {
  check(graph: SpecGraph): CoverageResult
}
```

**Fixtures**:
| Input | Expected | Case |
|-------|----------|------|
| Full coverage | {coverage: 100%} | Normal |
| Orphan items | {orphans: [...]} | Edge |
| Fanout > 7 | {violations: [Miller]} | Error |

---

## [interface] BATCH_READER

> Implements: [Component: COMPONENTS.IDEAS_PROCESSOR.BATCH_READER]

```typescript
interface BatchReader {
  read(path: string): Idea[]
}
```

**Fixtures**:
| Input | Expected | Case |
|-------|----------|------|
| "ideas/" with files | Idea[] | Normal |
| Empty dir | [] | Edge |
| No permission | ReadError | Error |

---

## [interface] SORTER

> Implements: [Component: COMPONENTS.IDEAS_PROCESSOR.SORTER]

```typescript
interface Sorter {
  sort(ideas: Idea[]): Idea[]
}
```

**Fixtures**:
| Input | Expected | Case |
|-------|----------|------|
| [10:05, 10:00, 10:10] | [10:00, 10:05, 10:10] | Normal |
| [] | [] | Edge |
| Same timestamp | Stable by name | Edge |

---

## [decision] LAYER_CLASSIFICATION

> Implements: [Role: ROLES.SPEC_MANAGEMENT.ARCHITECT]

**Rules**:
| Priority | Signal | Layer |
|----------|--------|-------|
| 1 | RFC2119 (MUST/SHOULD/SHALL/MAY) | L1 |
| 2 | Architecture entity (Role/Component) | L2 |
| 3 | Algorithm description | L3 |
| 4 | User expectation | L0 |
| 5 | Default | L0 + clarify |

**Fixtures**:
| Input | Expected | Reason |
|-------|----------|--------|
| "System MUST respond in 100ms" | L1 | RFC2119 |
| "Add Cache Component" | L2 | Component |
| "Use LRU algorithm" | L3 | Algorithm |
| "User wants fast response" | L0 | Vision |
| "Make it better" | L0 + clarify | Ambiguous |

(Ref: CONTRACTS.IDEAS_PIPELINE.LEVEL_SEEKING)

---

## [decision] CONFLICT_RESOLUTION

> Implements: [Role: ROLES.SPEC_MANAGEMENT.ARCHITECT]

**Rules**:
| Conflict Type | Action |
|--------------|--------|
| Different timestamps | Latest wins |
| Same timestamp | User decides |
| Mergeable | Merge + confirm |

**Fixtures**:
| Input | Expected | Case |
|-------|----------|------|
| [10:00, 10:05] conflict | 10:05 wins | Normal |
| Same timestamp | User decides | Edge |
| Mergeable content | Merge proposal | Edge |

(Ref: CONTRACTS.IDEAS_PIPELINE.CONFLICT_RES)

---

## [decision] RETRY_LOGIC

> Implements: [Role: ROLES.AUTOMATION.RECOVERY_AGENT]

**Rules**:
| Condition | Action |
|-----------|--------|
| Retry ‚â§ 3 + has alt | Try alt |
| Retry ‚â§ 3 + no alt | Revert + human |
| Retry > 3 | Revert + human |

**Fixtures**:
| Retry | HasAlt | Expected |
|-------|--------|----------|
| 1 | Yes | Retry(alt) |
| 3 | Yes | Retry(alt) |
| 4 | Yes | GiveUp |
| 1 | No | GiveUp |

(Ref: CONTRACTS.REJECTION_HANDLING.AUTOMATED_RETRY)

---

## [decision] TYPE_PURITY_CHECK

> Implements: [Role: ROLES.SPEC_MANAGEMENT.REVIEWER]

**Rules**:
| Signal | Type |
|--------|------|
| Semantic, context, judgment | Agent |
| Deterministic, transform | Script |

| Result | Action |
|--------|--------|
| Pure Agent | Pass |
| Pure Script | Pass |
| Mixed | Violation |

**Fixtures**:
| Description | Expected |
|-------------|----------|
| "Semantic analysis" | Pass (Agent) |
| "Sort and filter" | Pass (Script) |
| "Judge then sort" | Violation |

(Ref: CONTRACTS.LEAF_TYPE_PURITY)

---

## [decision] LAYER_REVIEW_CRITERIA

> Implements: [Role: ROLES.SPEC_MANAGEMENT.REVIEWER]

**Checklists by Layer**:
| Layer | Focus | Key Questions |
|-------|-------|---------------|
| L0 | Vision | Does it align with project philosophy? |
| L1 | Contracts | Is it testable? RFC2119 keywords? |
| L2 | Architecture | Agent vs Script? Max 3 refs? |
| L3 | Implementation | Fixtures complete? Type signature? |

**Fixtures**:
| Layer | Input | Expected | Case |
|---|---|---|---|
| L0 | Vision statement | Philosophy check | Normal |
| L1 | Contract item | RFC2119 validation | Normal |
| L2 | Role definition | Agent/Script purity | Normal |
| L3 | Interface | Fixture coverage | Normal |

## [algorithm] COVERAGE_VALIDATION

> Implements: [Component: COMPONENTS.VALIDATOR_CORE.RESPONSIVENESS_CHECKER]

```pseudocode
function validate_coverage(specs: Spec[]) -> Violation[]:
  violations = []
  graph = build_ref_graph(specs)
  
  for item in graph.upstream_items():
    downstream = graph.get_downstream(item.id)
    
    if len(downstream) == 0:
      violations.append(OrphanViolation(item.id))
    
    if len(downstream) > 7:
      violations.append(FanoutViolation(item.id))
  
  return violations
```

**Fixtures**:
| Input | Expected | Case |
|-------|----------|------|
| L0.A ‚Üí L1.B | [] | Normal |
| L0.A (orphan) | [OrphanViolation] | Edge |
| L0.A ‚Üí 8 items | [FanoutViolation] | Error |

(Ref: CONTRACTS.ALGEBRAIC_VALIDATION.CONSERVATION), (Ref: CONTRACTS.TRACEABILITY.L2_L3_IMPLEMENTATION)

---

## [interface] COVERAGE_ANALYZER

> Implements: [Component: COMPONENTS.INFRASTRUCTURE.COVERAGE_ANALYZER]

```typescript
interface CoverageAnalyzer {
  analyze(specs_dir: Path, tests_dir: Path): CoverageReport
}

interface CoverageReport {
  l1_coverage: number  // 0.0 - 1.0
  l3_coverage: number  // 0.0 - 1.0
  uncovered_ids: string[]
}
```

**Fixtures**:
| Input | Expected | Case |
|-------|----------|------|
| specs/ + tests/ | {l1: 0.8, l3: 0.6, []} | Normal |
| specs/ + empty tests/ | {l1: 0.0, l3: 0.0, [...]} | Edge |
| empty specs/ | EmptySpecError | Error |

(Ref: CONTRACTS.TESTING_WORKFLOW.COVERAGE_REPORT)

---

## [interface] TEST_EXECUTOR

> Implements: [Component: COMPONENTS.INFRASTRUCTURE.TEST_EXECUTOR]

```typescript
interface TestExecutor {
  run(tests_dir: Path, env: 'MOCK' | 'REAL'): ExecutionResult
}

interface ExecutionResult {
  passed: number
  failed: number
  skipped: number
  errors: number
}

type TestResultState = 'PASS' | 'FAIL' | 'SKIP' | 'ERROR'
```

**Fixtures**:
| Input | Expected | Case |
|-------|----------|------|
| tests/ + MOCK | {passed: 5, failed: 0, skipped: 0} | Normal |
| tests/ + REAL (all impl) | {passed: 4, failed: 1, skipped: 0} | Normal |
| tests/ + REAL (no impl) | {passed: 0, failed: 0, skipped: 5} | Edge (SKIP) |
| empty tests/ | {passed: 0, failed: 0, skipped: 0} | Edge |

(Ref: CONTRACTS.TESTING_WORKFLOW.EXECUTION_REPORT), (Ref: CONTRACTS.STRICT_TESTABILITY.SKIP_UNIMPLEMENTED), (Ref: CONTRACTS.STRICT_TESTABILITY.RESULT_STATES)

---

## [interface] TEST_REPORTER

> Implements: [Component: COMPONENTS.INFRASTRUCTURE.TEST_REPORTER]

```typescript
interface TestReporter {
  format(coverage: CoverageReport, execution: ExecutionResult): string
}
```

**Fixtures**:
| Input | Expected | Case |
|-------|----------|------|
| {80%, 60%} + {5, 0} | Formatted string | Normal |
| {0%, 0%} + {0, 0} | "No tests" warning | Edge |
| null coverage | ReportError | Error |

(Ref: CONTRACTS.TESTING_WORKFLOW.EXECUTION_REPORT)

---

## [interface] ADAPTER_FACTORY

> Implements: [Component: COMPONENTS.INFRASTRUCTURE.ADAPTER_FACTORY]

```typescript
interface AdapterFactory {
  get(interface_id: string, env: 'MOCK' | 'REAL'): Adapter
}

type Adapter = MockAdapter | RealAdapter | SkipAdapter

interface MockAdapter {
  type: 'mock'
  execute(input: any): FixtureResult
}

interface RealAdapter {
  type: 'real'
  execute(input: any): any
}

interface SkipAdapter {
  type: 'skip'
  reason: string
}
```

**Fixtures**:
| Input | Expected | Case |
|-------|----------|------|
| ("VALIDATOR", MOCK) | MockAdapter | Normal |
| ("VALIDATOR", REAL) | RealAdapter | Normal |
| ("VALIDATOR", REAL, no impl) | SkipAdapter("not implemented") | Edge |
| ("UNKNOWN", MOCK) | AdapterError | Error |

**Standards**:
- MockAdapter MUST use L3 Fixtures to return predefined results
- RealAdapter MUST attempt dynamic import from user project
- SkipAdapter MUST be returned when REAL impl not found (not throw)

(Ref: CONTRACTS.STRICT_TESTABILITY.ENVIRONMENT_TOGGLE), (Ref: CONTRACTS.STRICT_TESTABILITY.MOCK_GENERATION), (Ref: CONTRACTS.STRICT_TESTABILITY.SKIP_UNIMPLEMENTED)

---

## [interface] BUILDER

> Implements: [Component: COMPONENTS.INFRASTRUCTURE.BUILDER]

```typescript
interface Builder {
  build(compiled_spec: Path, skills: string[]): BuildResult
}

interface BuildResult {
  status: 'SUCCESS' | 'PARTIAL' | 'CONFLICT' | 'ERROR'
  updates: string[]
  warnings: string[]
}
```

**Fixtures**:
| Input | Expected | Case |
|-------|----------|------|
| spec + [skill] | SUCCESS, [src/SKILL.md updated] | Normal |
| spec + [no_skill] | PARTIAL, "Manual implementation required" | Edge |
| invalid spec | ERROR, "Traceability broken" | Error |

(Ref: VISION.VIBE_CODING.TRUTH)

---

## [interface] SECTION_PARSER

> Implements: [Component: COMPONENTS.COMPILER_PIPELINE.SECTION_PARSER]

```typescript
interface SectionParser {
  parse(content: string): Section[]
}
```

**Fixtures**:
| Input | Expected | Case |
|-------|----------|------|
| "## ID" | [{tag: "system", id: "ID"}] | Normal |
| "## ID" | [{tag: null, id: "ID"}] | Edge |
| "" | [] | Edge |

---

## [interface] CUSTOM_RULES_LOADER

> Implements: [Component: COMPONENTS.VALIDATOR_CORE.CUSTOM_RULES_LOADER]

```typescript
interface CustomRulesLoader {
  load(specsDir: Path): Rule[]
}
```

**Fixtures**:
| Input | Expected | Case |
|-------|----------|------|
| specs/ with rules | Rule[] | Normal |
| empty specs/ | [] | Edge |
| invalid YAML | LoadError | Error |

---

## [interface] ARCHIVER

> Implements: [Component: COMPONENTS.IDEAS_PROCESSOR.ARCHIVER]

```typescript
interface Archiver {
  archive(ideas: Idea[]): void
}
```

**Fixtures**:
| Input | Expected | Case |
|-------|----------|------|
| [idea1, idea2] | void (files moved) | Normal |
| [] | void (no-op) | Edge |
| read-only dir | ArchiveError | Error |

---

## [interface] SKILL_LOADER

> Implements: [Component: COMPONENTS.SCRIPTS.SKILL_LOADER]

```typescript
interface SkillLoader {
  load(path: Path): SkillDef
}
```

**Fixtures**:
| Input | Expected | Case |
|-------|----------|------|
| valid SKILL.md | SkillDef | Normal |
| no SKILL.md | null | Edge |
| malformed | ParseError | Error |

---

## [interface] INIT_SCRIPT

> Implements: [Component: COMPONENTS.SCRIPTS.INIT_SCRIPT]

```typescript
interface InitScript {
  init(projectDir: Path): InitResult
  generateConfig(): Path
}
```

**Fixtures**:
| Input | Expected | Case |
|-------|----------|------|
| empty dir | L0 + Config | Normal |
| existing project | SKIP | Edge |
| minimal init | Config Only | Config Gen |
| no permissions | InitError | Error |

**Standards**:
- **USE_CONFIG_TEMPLATE**: `generateConfig()` MUST read from `assets/templates/vibespec.yaml`.
  - Template defines: `unit_dir` and `agent_dir` per L3 Structure standards.
  - User customization applied on top of template.
  (Ref: CONTRACTS.BOOTSTRAP.CONFIG_TEMPLATE)

---

## [interface] VALIDATE_SCRIPT

> Implements: [Component: COMPONENTS.SCRIPTS.VALIDATE_SCRIPT]

```typescript
interface ValidateScript {
  validate(specsDir: Path): ValidationResult
}
```

**Fixtures**:
| Input | Expected | Case |
|-------|----------|------|
| valid specs | {errors: 0} | Normal |
| invalid specs | {errors: N} | Normal |
| no specs | EmptyError | Edge |

---

## [interface] COMPILE_SCRIPT

> Implements: [Component: COMPONENTS.SCRIPTS.COMPILE_SCRIPT]

```typescript
interface CompileScript {
  compile(specsDir: Path, output: Path): void
}
```

**Fixtures**:
| Input | Expected | Case |
|-------|----------|------|
| specs/ -> out.md | void | Normal |
| no specs | CompileError | Error |
| invalid output | WriteError | Error |

**Standards**:
- **META_TEST_STRUCTURE**:
  - `tests/specs/agent/` : `answer_key_{snake_case_id}.md`
  - `tests/specs/script/unit/` : `test_{snake_case_id}.py`
  - `tests/specs/script/e2e/` : `test_{snake_case_id}.py`

---

## [interface] BUILD_SCRIPT

> Implements: [Component: COMPONENTS.SCRIPTS.BUILD_SCRIPT]

```typescript
interface BuildScript {
  build(config: Path): BuildReport
}
```

**Fixtures**:
| Input | Expected | Case |
|-------|----------|------|
| valid config | Report | Normal |
| no config | Error | Missing Config |
| drift detected | Warning | Drift |

**Standards**:
- **SKILL_LOAD_SYNC**: `build()` MUST read `project.skills` from `vibespec.yaml`.
  - Ensures agents operate with explicit skill set.
  (Ref: CONTRACTS.BUILD_STRATEGY.SKILL_SYNC)

---

## [interface] COMMAND_ROUTER

> Implements: [Component: COMPONENTS.TRIGGER_ROUTER.COMMAND_ROUTER]

```typescript
interface CommandRouter {
  route(command: string): Handler
}
```

**Fixtures**:
| Input | Expected | Case |
|-------|----------|------|
| "validate" | ValidateHandler | Normal |
| "unknown" | HelpHandler | Edge |
| "" | HelpHandler | Edge |

---

## [interface] WORKFLOW_DISPATCHER

> Implements: [Component: COMPONENTS.TRIGGER_ROUTER.WORKFLOW_DISPATCHER]

```typescript
interface WorkflowDispatcher {
  dispatch(trigger: Trigger): void
}
```

**Fixtures**:
| Input | Expected | Case |
|-------|----------|------|
| FileSave trigger | RunValidation | Normal |
| Unknown trigger | NoOp | Edge |
| null | DispatchError | Error |

---

## [interface] LINT_CHECKER

> Implements: [Component: COMPONENTS.QUALITY.LINT_CHECKER]

```typescript
interface LintChecker {
  check(spec: Spec): LintResult
}
```

**Fixtures**:
| Input | Expected | Case |
|-------|----------|------|
| valid spec | {issues: []} | Normal |
| missing tag | {issues: [TagWarning]} | Edge |
| malformed | LintError | Error |

---

## [interface] ASSERTION_CHECKER

> Implements: [Component: COMPONENTS.QUALITY.ASSERTION_CHECKER]

```typescript
interface AssertionChecker {
  check(spec: Spec): AssertionResult
}
```

**Fixtures**:
| Input | Expected | Case |
|-------|----------|------|
| RFC2119 compliant | {pass: true} | Normal |
| low keyword density | {pass: false} | Edge |
| empty spec | AssertionError | Error |

---

## [interface] NOTATION_CHECKER

> Implements: [Component: COMPONENTS.QUALITY.NOTATION_CHECKER]

```typescript
interface NotationChecker {
  check(spec: Spec): NotationResult
}
```

**Fixtures**:
| Input | Expected | Case |
|-------|----------|------|
| valid notation | {issues: []} | Normal |
| informal language | {issues: [Warn]} | Edge |
| mixed case IDs | {issues: [Error]} | Error |

---

## [interface] TERM_CHECKER

> Implements: [Component: COMPONENTS.QUALITY.TERM_CHECKER]

```typescript
interface TermChecker {
  check(spec: Spec, vocab: Vocabulary): TermResult
}
```

**Fixtures**:
| Input | Expected | Case |
|-------|----------|------|
| controlled terms | {violations: []} | Normal |
| banned term | {violations: [TermViolation]} | Error |
| unknown term | {warnings: [UnknownTerm]} | Edge |

---

## [interface] PURITY_CHECKER

> Implements: [Component: COMPONENTS.QUALITY.PURITY_CHECKER]

```typescript
interface PurityChecker {
  check(spec: Spec): PurityResult
}
```

**Fixtures**:
| Input | Expected | Case |
|-------|----------|------|
| pure spec | {pure: true} | Normal |
| impl details in L0 | {pure: false} | Error |
| mixed concerns | {warnings: [Impure]} | Edge |

---

## [interface] SCRIPT_SCANNER

> Implements: [Component: COMPONENTS.QUALITY.SCRIPT_SCANNER]

```typescript
interface ScriptScanner {
  scan(spec: Spec): ScriptRef[]
}
```

**Fixtures**:
| Input | Expected | Case |
|-------|----------|------|
| L3 with scripts | [ScriptRef] | Normal |
| no scripts | [] | Edge |
| broken ref | ScanError | Error |

---

## [interface] ERROR_PRINTER

> Implements: [Component: COMPONENTS.REPORTING.ERROR_PRINTER]

```typescript
interface ErrorPrinter {
  print(errors: Violation[]): string
}
```

**Fixtures**:
| Input | Expected | Case |
|-------|----------|------|
| [error1] | "‚ùå error1" | Normal |
| [] | "" | Edge |
| null | PrintError | Error |

---

## [interface] DIFF_VIEWER

> Implements: [Component: COMPONENTS.REPORTING.DIFF_VIEWER]

```typescript
interface DiffViewer {
  diff(before: Spec, after: Spec): DiffResult
}
```

**Fixtures**:
| Input | Expected | Case |
|-------|----------|------|
| changed spec | {added: N, removed: M} | Normal |
| identical | {added: 0, removed: 0} | Edge |
| null input | DiffError | Error |

---

## [interface] SUMMARY_GENERATOR

> Implements: [Component: COMPONENTS.REPORTING.SUMMARY_GENERATOR]

```typescript
interface SummaryGenerator {
  generate(result: ValidationResult): string
}
```

**Fixtures**:
| Input | Expected | Case |
|-------|----------|------|
| 0 errors | "‚úÖ Valid" | Normal |
| N errors | "‚ùå N errors" | Error |
| null | SummaryError | Error |

---

## [interface] ATOMIC_WRITER

> Implements: [Component: COMPONENTS.INFRASTRUCTURE.ATOMIC_WRITER]

```typescript
interface AtomicWriter {
  write(path: Path, content: string): void
}
```

**Fixtures**:
| Input | Expected | Case |
|-------|----------|------|
| valid path | void (file written) | Normal |
| readonly path | WriteError | Error |
| concurrent write | AtomicGuard | Edge |

---

## [interface] STATS_COLLECTOR

> Implements: [Component: COMPONENTS.INFRASTRUCTURE.STATS_COLLECTOR]

```typescript
interface StatsCollector {
  collect(specs: Spec[]): Stats
}
```

**Fixtures**:
| Input | Expected | Case |
|-------|----------|------|
| [spec1, spec2] | {count: 2, ...} | Normal |
| [] | {count: 0} | Edge |
| null | StatsError | Error |

---

## [decision] TEST_DESIGNER

> Implements: [Role: ROLES.AUTOMATION.TEST_DESIGNER]

**Decision Logic**:
1. Analyze L3 fixtures for testable scenarios
2. Determine test strategy (unit/integration)
3. Generate test code with `@verify_spec` decorators

**Fixtures**:
| Situation | Decision | Rationale |
|-----------|----------|-----------|
| L3 with fixtures | Generate tests | Has concrete cases |
| L3 no fixtures | Request fixtures | Missing test data |
| Complex algorithm | Integration test | Needs end-to-end |

---

## [decision] TEST_VERIFIER

> Implements: [Role: ROLES.AUTOMATION.TEST_VERIFIER]

**Decision Logic**:
1. Run generated tests
2. Compare results to expected outcomes
3. Report pass/fail with evidence

**Fixtures**:
| Situation | Decision | Rationale |
|-----------|----------|-----------|
| All pass | Report success | Tests green |
| Failures | Report with diff | Show evidence |
| Flaky test | Rerun and flag | Detect instability |

---

## [decision] IMPLEMENTER

> Implements: [Role: ROLES.AUTOMATION.IMPLEMENTER]

**Decision Logic**:
1. Perform gap analysis
2. Decide refactor vs rewrite
3. Apply incremental changes

**Fixtures**:
| Situation | Decision | Rationale |
|-----------|----------|-----------|
| Gap < 30% | Incremental | Low risk |
| Gap > 70% | Request approval | High risk |
| Orphan code | Flag for removal | Spec drift |

---

## [decision] PATTERN_SCOUT

> Implements: [Role: ROLES.AUTOMATION.PATTERN_SCOUT]

**Decision Logic**:
1. Analyze code for repeated patterns
2. Identify abstraction opportunities
3. Suggest refactoring

**Fixtures**:
| Situation | Decision | Rationale |
|-----------|----------|-----------|
| 3+ similar blocks | Suggest abstract | DRY principle |
| Unique code | No action | No pattern |
| Anti-pattern | Flag warning | Code smell |

---

## [decision] INSIGHT_MINER

> Implements: [Role: ROLES.AUTOMATION.INSIGHT_MINER]

**Decision Logic**:
1. Analyze spec evolution
2. Identify trends and issues
3. Generate insights

**Fixtures**:
| Situation | Decision | Rationale |
|-----------|----------|-----------|
| Growing complexity | Warn | Maintenance risk |
| Stable specs | Report health | Good sign |
| Frequent changes | Flag volatility | Instability |

---

## [decision] QUALITY_AUDITOR

> Implements: [Role: ROLES.SPEC_MANAGEMENT.QUALITY_AUDITOR]

**Decision Logic**:
1. Check spec quality metrics
2. Compare to thresholds
3. Report violations

**Fixtures**:
| Situation | Decision | Rationale |
|-----------|----------|-----------|
| RFC2119 > 50% | Pass | Good density |
| RFC2119 < 50% | Warn | Weak assertions |
| Missing fixtures | Error | Untestable |

---

## [decision] CONSISTENCY_CHECKER

> Implements: [Role: ROLES.SPEC_MANAGEMENT.CONSISTENCY_CHECKER]

**Decision Logic**:
1. Compare related specs
2. Detect contradictions
3. Flag inconsistencies

**Fixtures**:
| Situation | Decision | Rationale |
|-----------|----------|-----------|
| Aligned specs | Pass | Consistent |
| Contradiction | Error | Conflict |
| Ambiguity | Warn | Clarification needed |

---

## [decision] USER_LIAISON

> Implements: [Role: ROLES.USER_INTERACTION.USER_LIAISON]

**Decision Logic**:
1. Receive user requests
2. Route to appropriate workflow
3. Report results

**Fixtures**:
| Situation | Decision | Rationale |
|-----------|----------|-----------|
| "validate" | Run validation | Direct command |
| "help" | Show help | Guidance needed |
| Ambiguous | Ask clarification | Unclear intent |

---

## [decision] BOOTSTRAP_AGENT

> Implements: [Role: ROLES.USER_INTERACTION.BOOTSTRAP_AGENT]

**Decision Logic**:
1. Check project state
2. Initialize if needed
3. Report status

**Fixtures**:
| Situation | Decision | Rationale |
|-----------|----------|-----------|
| No vibespec.yaml | Run init | New project |
| Existing project | Skip init | Already setup |
| Partial setup | Resume init | Incomplete |

---

## [decision] ONBOARDING_ASSISTANT

> Implements: [Role: ROLES.USER_INTERACTION.ONBOARDING_ASSISTANT]

**Decision Logic**:
1. Assess user familiarity
2. Provide appropriate guidance
3. Offer examples

**Fixtures**:
| Situation | Decision | Rationale |
|-----------|----------|-----------|
| New user | Full tutorial | Learning curve |
| Experienced | Quick tips | Efficiency |
| Stuck user | Contextual help | Unblock |

---

## [decision] RELOAD_DECISION

> Implements: [Role: ROLES.AUTOMATION.RELOAD_HANDLER]

**Decision Logic**:
1. Receive `vibespec reload` command
2. Re-read SKILL.md from disk
3. Confirm reload to user

**Fixtures**:
| Situation | Decision | Rationale |
|-----------|----------|-----------|
| SKILL.md exists | Reload and confirm | Hot-reload |
| SKILL.md missing | Error message | Fail gracefully |

---

## [workflow] AUTOMATE_WORKFLOW

> Implements: [Role: ROLES.AUTOMATION.AUTOMATE_CONTROLLER]

**Steps**:
1. Trigger: `vibespec automate`
2. Scan: `specs/ideas/` -> `pending_ideas[]`
3. Loop for each `idea` in `pending_ideas`:
   a. **[Agent: INSIGHT_MINER]** Refinement: Breakdown idea to L1/L2/L3
   b. **[Script: VALIDATOR]** Validation: Run `python validate.py`
   c. **[Agent: PROCESS_ENFORCER]** Oversight: Check for cascade warnings
   d. **[Agent: IMPLEMENTER]** Fix: Resolve warnings
4. **[Script: COMPILER]** Compile: Run `python compile.py`
5. **[Script: BUILDER]** Build: Sync artifacts via `vibespec build`
6. **[Script: TEST_RUNNER]** Test: Run `python test.py`
7. Final: **[Script: CLI]** Report success

**Fixtures**:
| Initial State | Sequence of Events | Expected Final State |
|---|---|---|
| {ideas: 2, warnings: 0} | [automate_command] | {ideas: 0, warnings: 0} |
| {ideas: 0, warnings: 2} | [automate_command] | {ideas: 0, warnings: 0} |
| {ideas: 1, warnings: 1} | [automate_command, validation_fail] | {ideas: 1, warnings: 1, error: logged} |

---

## [interface] TEMPLATE_LOADER_INTERFACE

> Implements: [Component: COMPONENTS.INFRASTRUCTURE.TEMPLATE_LOADER]

```typescript
interface TemplateLoader {
  load(templateDir: string): Map<LayerType, Template>
}
```

**Fixtures**:
| Input | Expected | Case |
|-------|----------|------|
| "src/assets/specs/" | Map{L0, L1, L2, L3} | Normal |
| "nonexistent/" | PathError | Error |

---

## [interface] CERTIFICATION_ENGINE_INTERFACE

> Implements: [Component: COMPONENTS.INFRASTRUCTURE.CERTIFICATION_ENGINE]

```typescript
interface CertificationEngine {
  generateAnswerKey(spec: Spec): AnswerKeyFile
  combineQuestionPaper(keys: AnswerKeyFile[]): QuestionPaper
}
```

**Fixtures**:
| Input | Expected | Case |
|-------|----------|------|
| L1 spec item | answer_key_{id}.md | Normal |
| Empty specs | [] | Edge |

---

## [decision] PROCESS_ENFORCER_DECISION

> Implements: [Role: ROLES.SPEC_MANAGEMENT.PROCESS_ENFORCER]

**Decision Logic**:
1. Check if edit spans multiple layers (L1 + L2)
2. Check if persistent action (write) has prior human approval
3. Block if violation detected

**Fixtures**:
| Situation | Decision | Rationale |
| Edit L1 + L2 | Block | SEQUENTIAL_ONLY |
| Write L1 w/o approval | Block | REFL.HUMAN_REVIEW |
| Edit L1 only | Allow | Valid op |

---

## [algorithm] SCENARIO_GENERATION

> Implements: [Role: ROLES.QUALITY.TEST_DESIGNER]

**Logic**:
1. Scan project `src/` to identify domain (e.g., Models, APIs).
2. Scan `specs/` to identify recent changes or core features.
3. Construct E2E workflow: `Idea -> Spec -> Impl -> Verify`.
4. Output: `[workflow] PROJECT_E2E_SCENARIO`

```typescript
function generateScenario(project: ProjectContext): Workflow
```

**Fixtures**:
| Context | Generated Scenario | Rationale | Case |
|---|---|---|---|
| User Model exists | Add field 'phone' to User | CRUD mutability check | Normal |
| Empty Project | Add 'Hello World' feature | Bootstrap check | Edge |

---

## [interface] SCENARIO_DRIVER_INTERFACE

> Implements: [Component: COMPONENTS.INFRASTRUCTURE.SCENARIO_DRIVER]

```typescript
interface ScenarioDriver {
  run(workflow: Workflow): Result
}
```

**Fixtures**:
| Input | Expected | Case |
|---|---|---|
| Valid Workflow | PASS | Normal |
| Broken Workflow | FAIL | Error |

---

## [workflow] FULL_WORKFLOW

> Implements: [Contract: CONTRACTS.STRICT_TESTABILITY.FULL_WORKFLOW_REQUIRED]

**Purpose**: End-to-end test covering all Roles and Components in a realistic project scenario.

**Steps**:
1. `SCANNER.scan("specs/")` ‚Üí File[]
2. `PARSER.parse(files)` ‚Üí Spec[]
3. `VALIDATOR.validate(specs)` ‚Üí ValidationResult
4. `ASSEMBLER.assemble(specs)` ‚Üí CompiledSpec
5. [Role] `ARCHITECT.review(compiled)` ‚Üí ReviewResult (mocked)
6. [Role] `IMPLEMENTER.implement(approved)` ‚Üí Implementation (mocked)
7. `TEST_EXECUTOR.run(tests, MOCK)` ‚Üí TestResult
8. `TEST_REPORTER.format(result)` ‚Üí Report

**Coverage**:
- Roles: ARCHITECT, IMPLEMENTER, REVIEWER (all mocked)
- Components: SCANNER, PARSER, VALIDATOR, ASSEMBLER, TEST_EXECUTOR, TEST_REPORTER

**Fixtures**:
| Scenario | Expected | Case |
|----------|----------|------|
| Full compile + test flow | All steps pass | Normal |
| Validation fails at step 3 | Workflow halts, reports error | Error |
| Role returns reject | Workflow handles rejection | Edge |

(Ref: CONTRACTS.STRICT_TESTABILITY.FULL_WORKFLOW_REQUIRED), (Ref: CONTRACTS.STRICT_TESTABILITY.WORKFLOW_INTEROP_COVERAGE), (Ref: CONTRACTS.STRICT_TESTABILITY.ROLE_ALWAYS_MOCK)

---

## [interface] WORKFLOW_TEST_EXECUTOR

> Implements: [Component: COMPONENTS.INFRASTRUCTURE.WORKFLOW_TEST_EXECUTOR]

```typescript
interface WorkflowTestExecutor {
  run(workflow_id: string, env: 'MOCK' | 'REAL'): WorkflowResult
}

interface WorkflowResult {
  passed: boolean
  failed_step?: string
  steps_executed: string[]
}
```

**Fixtures**:
| Input | Expected | Case |
|-------|----------|------|
| ("FULL_WORKFLOW", MOCK) | {passed: true, steps: [...]} | Normal |
| ("FULL_WORKFLOW", REAL) | {passed: true, steps: [...]} | Normal (roles still mock) |
| ("UNKNOWN_WORKFLOW", MOCK) | WorkflowNotFoundError | Error |

**Standards**:
- Role steps MUST use mocked output regardless of env
- Component steps follow env-based adapter selection

(Ref: CONTRACTS.STRICT_TESTABILITY.ROLE_ALWAYS_MOCK), (Ref: CONTRACTS.STRICT_TESTABILITY.WORKFLOW_INTEROP_COVERAGE)

