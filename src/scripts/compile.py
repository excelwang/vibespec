#!/usr/bin/env python3
"""
Spec Compiler - Assembles specification layers into a unified document.
Also generates Meta-Tests in tests/specs/ during compilation.

Zero third-party dependencies - uses Python stdlib only.
Version: 3.2.0

Configuration: Reads from vibespec.yaml if present.
"""
import sys
import re
from pathlib import Path


def load_config(project_root: Path) -> dict:
    """Load configuration from vibespec.yaml if present."""
    config_file = project_root / 'vibespec.yaml'
    if not config_file.exists():
        return {}
    
    # Simple YAML parsing for basic key-value structure (no external deps)
    config = {}
    current_section = None
    content = config_file.read_text()
    
    for line in content.split('\n'):
        stripped = line.strip()
        if not stripped or stripped.startswith('#'):
            continue
        
        # Section header
        if not line.startswith(' ') and stripped.endswith(':') and ':' not in stripped[:-1]:
            current_section = stripped[:-1]
            config[current_section] = {}
        # Key-value in section
        elif current_section and ':' in stripped:
            key, value = stripped.split(':', 1)
            value = value.strip().strip('"\'')
            config[current_section][key.strip()] = value
    
    return config


def generate_meta_tests(specs_dir: Path, tests_dir: Path):
    """Generate Meta-Tests in structured directories."""
    # Structure: tests/specs/script/unit/
    unit_tests_dir = tests_dir / "specs" / "script" / "unit"
    unit_tests_dir.mkdir(parents=True, exist_ok=True)
    
    # Structure: tests/specs/agent/
    agent_tests_dir = tests_dir / "specs" / "agent"
    agent_tests_dir.mkdir(parents=True, exist_ok=True)
    
    generated_count = 0
    
    existing_tests = set(unit_tests_dir.glob("test_*.py"))
    generated_files = set()

    for f in specs_dir.glob("L3*.md"):
        content = f.read_text()
        
        # Find fixtures: ## [interface|decision|algorithm] ID
        fixtures = re.findall(r'^## \[(interface|decision|algorithm)\]\s+(.+)$', content, re.MULTILINE)
        
        for f_type, f_id in fixtures:
            # Sanitize ID for filename
            safe_id = re.sub(r'[^a-zA-Z0-9_]', '_', f_id).lower()
            test_file = unit_tests_dir / f"test_{safe_id}.py"
            generated_files.add(test_file)
            
            if not test_file.exists():
                test_content = f"""# Meta-Test for {f_id} ({f_type})
# Generated by Vibespec Compiler
# ref: {f_id}

import unittest

class Test{f_id.replace('_', '').replace('.', '')}(unittest.TestCase):
    def test_compliance(self):
        # TODO: Implement compliance verification for {f_id}
        pass

if __name__ == '__main__':
    unittest.main()
"""
                test_file.write_text(test_content)
                generated_count += 1
            else:
                # Optional: Check for drift provided we can parse the ref
                pass

    # Report Orphans
    orphans = existing_tests - generated_files
    if orphans:
        print(f"âš ï¸  Orphaned tests found (spec deleted?):")
        for o in orphans:
            print(f"   - {o.name}")
                
    skipped_count = len(generated_files) - generated_count
    if generated_count > 0 or skipped_count > 0:
        print(f"âœ… Generated {generated_count} unit meta-tests (Skipped {skipped_count} existing) in {unit_tests_dir}")

    # Structural & Naming Validation
    specs_root = tests_dir / "specs"
    if specs_root.exists():
        naming_rules = {
            "agent": re.compile(r"^(answer_key|generated_question_paper)_[a-z0-9_]+\.md$"),
            "unit": re.compile(r"^test_[a-z0-9_]+\.py$"),
            "e2e": re.compile(r"^test_[a-z0-9_]+\.py$")
        }
        
        misplaced = []
        bad_names = []
        
        for f in specs_root.rglob("*"):
            if f.is_file() and f.suffix in ['.py', '.md'] and "__pycache__" not in f.parts:
                # Identify category
                category = None
                if str(f).startswith(str(specs_root / "agent")):
                    category = "agent"
                elif str(f).startswith(str(specs_root / "script" / "unit")):
                    category = "unit"
                elif str(f).startswith(str(specs_root / "script" / "e2e")):
                    category = "e2e"
                
                if category:
                    if not naming_rules[category].match(f.name):
                        bad_names.append(f)
                else:
                    misplaced.append(f)
        
        if misplaced:
            print(f"âš ï¸  Structural Violations (Misplaced files in {specs_root}):")
            for m in misplaced:
                print(f"   - {m.relative_to(specs_root)}")
                
        if bad_names:
            print(f"âš ï¸  Naming Violations (Invalid pattern):")
            for b in bad_names:
                print(f"   - {b.relative_to(specs_root)}")


def compile_specs(specs_dir: Path, output_file: Path, tests_dir: Path = None):
    """Concatenate all L*.md files into a single compiled spec with LLM-friendly structure."""
    if not specs_dir.exists():
        print(f"Error: {specs_dir} does not exist.")
        sys.exit(1)

    content = []
    files = sorted(specs_dir.glob("L*.md"))

    # 1. Preamble & System Context
    content.append("# VIBESPEC PROJECT SPECS (v3.2.0)\n")
    content.append("> ðŸš¨ INSTRUCTION: You are an Agent reading the Project Bible.\n")
    content.append("> 1. Always check `L1: Contracts` before writing code.\n")
    content.append("> 2. `L0: Vision` defines the scope. Do not hallucinate features.\n")
    content.append("> 3. `L1` overrides `L3` if there is a conflict.\n\n")

    # 2. Table of Contents
    content.append("## ðŸ—ºï¸ INDEX\n")
    for f in files:
        anchor = f"source-{f.stem.lower()}"
        content.append(f"- [{f.stem}: {f.stem.split('-')[1] if '-' in f.stem else f.stem}](#{anchor})\n")
    content.append("\n---\n\n")

    # 3. Concatenate Files
    for f in files:
        file_text = f.read_text()
        
        # Strip YAML Frontmatter (between first two '---')
        parts = file_text.split('---', 2)
        if len(parts) >= 3 and parts[0].strip() == "":
            body = parts[2].strip()
        else:
            body = file_text.strip() # Handle files without frontmatter or with different structure

        # Add Context Anchor
        content.append(f"<a id='source-{f.stem.lower()}'></a>\n")
        content.append(f"# Source: {f.name}\n")
        content.append(f"RELIABILITY: {'Use for Context' if 'L0' in f.name else 'AUTHORITATIVE'}\n")
        content.append("---\n\n")
        content.append(body)
        content.append("\n\n")

    # 4. Write Output
    output_file.write_text("".join(content))
    print(f"âœ… Compiled {len(files)} specs to {output_file}")
    
    # 5. Generate Meta-Tests
    if tests_dir:
        generate_meta_tests(specs_dir, tests_dir)


if __name__ == "__main__":
    import argparse
    parser = argparse.ArgumentParser(
        description='Compile Vibespec files into a unified document.',
        epilog='Example: python compile.py specs/ specs/.compiled.md'
    )
    parser.add_argument('specs_dir', nargs='?', help='Directory containing L*.md spec files')
    parser.add_argument('output_file', nargs='?', help='Output file path for compiled spec')
    parser.add_argument('--tests-dir', help='Directory to generate meta-tests in')
    args = parser.parse_args()
    
    # Load config from vibespec.yaml if arguments not provided
    project_root = Path.cwd()
    config = load_config(project_root)
    
    specs_dir = Path(args.specs_dir) if args.specs_dir else Path(config.get('build', {}).get('specs_dir', 'specs/'))
    output_file = Path(args.output_file) if args.output_file else Path(config.get('build', {}).get('compiled_spec', 'specs/.compiled.md'))
    tests_dir = Path(args.tests_dir) if args.tests_dir else Path('tests')
    
    compile_specs(specs_dir, output_file, tests_dir)
